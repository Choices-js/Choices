{"version":3,"file":"choices.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 56124b313c3da0d83eea","webpack:///src/scripts/src/choices.js","webpack:///./~/fuse.js/src/fuse.js","webpack:///./~/classnames/index.js","webpack:///src/scripts/src/store/store.js","webpack:///./~/redux/lib/index.js","webpack:///./~/redux/lib/createStore.js","webpack:///./~/lodash/isPlainObject.js","webpack:///./~/lodash/_baseGetTag.js","webpack:///./~/lodash/_Symbol.js","webpack:///./~/lodash/_root.js","webpack:///./~/lodash/_freeGlobal.js","webpack:///./~/lodash/_getRawTag.js","webpack:///./~/lodash/_objectToString.js","webpack:///./~/lodash/_getPrototype.js","webpack:///./~/lodash/_overArg.js","webpack:///./~/lodash/isObjectLike.js","webpack:///./~/symbol-observable/index.js","webpack:///./~/symbol-observable/lib/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/symbol-observable/lib/ponyfill.js","webpack:///./~/redux/lib/combineReducers.js","webpack:///./~/redux/lib/utils/warning.js","webpack:///./~/redux/lib/bindActionCreators.js","webpack:///./~/redux/lib/applyMiddleware.js","webpack:///./~/redux/lib/compose.js","webpack:///src/scripts/src/reducers/index.js","webpack:///src/scripts/src/reducers/items.js","webpack:///src/scripts/src/reducers/groups.js","webpack:///src/scripts/src/reducers/choices.js","webpack:///src/scripts/src/components/dropdown.js","webpack:///src/scripts/src/components/container.js","webpack:///src/scripts/src/components/input.js","webpack:///src/scripts/src/lib/utils.js","webpack:///src/scripts/src/components/list.js","webpack:///src/scripts/src/actions/actions.js","webpack:///src/scripts/src/lib/polyfills.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Choices\"] = factory();\n\telse\n\t\troot[\"Choices\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/src/scripts/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 56124b313c3da0d83eea","import Fuse from 'fuse.js';\nimport classNames from 'classnames';\nimport Store from './store/store';\nimport Dropdown from './components/dropdown';\nimport Container from './components/container';\nimport Input from './components/input';\nimport List from './components/list';\nimport {\n  addItem,\n  removeItem,\n  highlightItem,\n  addChoice,\n  filterChoices,\n  activateChoices,\n  addGroup,\n  clearAll,\n  clearChoices,\n} from './actions/actions';\nimport {\n  isScrolledIntoView,\n  getAdjacentEl,\n  wrap,\n  getType,\n  isType,\n  isElement,\n  strToEl,\n  extend,\n  sortByAlpha,\n  sortByScore,\n  generateId,\n  triggerEvent,\n  findAncestorByAttrName,\n  regexFilter,\n} from './lib/utils';\nimport './lib/polyfills';\n\n/**\n * Choices\n */\nclass Choices {\n  constructor(element = '[data-choice]', userConfig = {}) {\n    // If there are multiple elements, create a new instance\n    // for each element besides the first one (as that already has an instance)\n    if (isType('String', element)) {\n      const elements = document.querySelectorAll(element);\n      if (elements.length > 1) {\n        for (let i = 1; i < elements.length; i += 1) {\n          const el = elements[i];\n          /* eslint-disable no-new */\n          new Choices(el, userConfig);\n        }\n      }\n    }\n\n    const defaultConfig = {\n      silent: false,\n      items: [],\n      choices: [],\n      renderChoiceLimit: -1,\n      maxItemCount: -1,\n      addItems: true,\n      removeItems: true,\n      removeItemButton: false,\n      editItems: false,\n      duplicateItems: true,\n      delimiter: ',',\n      paste: true,\n      searchEnabled: true,\n      searchChoices: true,\n      searchFloor: 1,\n      searchResultLimit: 4,\n      searchFields: ['label', 'value'],\n      position: 'auto',\n      resetScrollPosition: true,\n      regexFilter: null,\n      shouldSort: true,\n      shouldSortItems: false,\n      sortFilter: sortByAlpha,\n      placeholder: true,\n      placeholderValue: null,\n      searchPlaceholderValue: null,\n      prependValue: null,\n      appendValue: null,\n      renderSelectedChoices: 'auto',\n      loadingText: 'Loading...',\n      noResultsText: 'No results found',\n      noChoicesText: 'No choices to choose from',\n      itemSelectText: 'Press to select',\n      addItemText: value => `Press Enter to add <b>\"${value}\"</b>`,\n      maxItemText: maxItemCount => `Only ${maxItemCount} values can be added.`,\n      uniqueItemText: 'Only unique values can be added.',\n      classNames: {\n        containerOuter: 'choices',\n        containerInner: 'choices__inner',\n        input: 'choices__input',\n        inputCloned: 'choices__input--cloned',\n        list: 'choices__list',\n        listItems: 'choices__list--multiple',\n        listSingle: 'choices__list--single',\n        listDropdown: 'choices__list--dropdown',\n        item: 'choices__item',\n        itemSelectable: 'choices__item--selectable',\n        itemDisabled: 'choices__item--disabled',\n        itemChoice: 'choices__item--choice',\n        placeholder: 'choices__placeholder',\n        group: 'choices__group',\n        groupHeading: 'choices__heading',\n        button: 'choices__button',\n        activeState: 'is-active',\n        focusState: 'is-focused',\n        openState: 'is-open',\n        disabledState: 'is-disabled',\n        highlightedState: 'is-highlighted',\n        hiddenState: 'is-hidden',\n        flippedState: 'is-flipped',\n        loadingState: 'is-loading',\n        noResults: 'has-no-results',\n        noChoices: 'has-no-choices',\n      },\n      fuseOptions: {\n        include: 'score',\n      },\n      callbackOnInit: null,\n      callbackOnCreateTemplates: null,\n    };\n\n    this.idNames = {\n      itemChoice: 'item-choice',\n    };\n\n    // Merge options with user options\n    this.config = extend(defaultConfig, Choices.userDefaults, userConfig);\n\n    if (!['auto', 'always'].includes(this.config.renderSelectedChoices)) {\n      this.config.renderSelectedChoices = 'auto';\n    }\n\n    // Create data store\n    this.store = new Store(this.render);\n\n    // State tracking\n    this.initialised = false;\n    this.currentState = {};\n    this.prevState = {};\n    this.currentValue = '';\n\n    // Retrieve triggering element (i.e. element with 'data-choice' trigger)\n    this.element = element;\n    this.passedElement = isType('String', element) ? document.querySelector(element) : element;\n\n    if (!this.passedElement) {\n      if (!this.config.silent) {\n        console.error('Passed element not found');\n      }\n      return false;\n    }\n\n    this.isTextElement = this.passedElement.type === 'text';\n    this.isSelectOneElement = this.passedElement.type === 'select-one';\n    this.isSelectMultipleElement = this.passedElement.type === 'select-multiple';\n    this.isSelectElement = this.isSelectOneElement || this.isSelectMultipleElement;\n    this.isValidElementType = this.isTextElement || this.isSelectElement;\n    this.isIe11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));\n    this.isScrollingOnIe = false;\n\n    if (this.config.shouldSortItems === true && this.isSelectOneElement) {\n      if (!this.config.silent) {\n        console.warn(\n          'shouldSortElements: Type of passed element is \\'select-one\\', falling back to false.',\n        );\n      }\n    }\n\n    this.highlightPosition = 0;\n    this.canSearch = this.config.searchEnabled;\n\n    this.placeholder = false;\n    if (!this.isSelectOneElement) {\n      this.placeholder = this.config.placeholder ?\n        (this.config.placeholderValue || this.passedElement.getAttribute('placeholder')) :\n        false;\n    }\n\n    // Assign preset choices from passed object\n    this.presetChoices = this.config.choices;\n\n    // Assign preset items from passed object first\n    this.presetItems = this.config.items;\n\n    // Then add any values passed from attribute\n    if (this.passedElement.value) {\n      this.presetItems = this.presetItems.concat(\n        this.passedElement.value.split(this.config.delimiter),\n      );\n    }\n\n    // Set unique base Id\n    this.baseId = generateId(this.passedElement, 'choices-');\n\n    // Bind methods\n    this.render = this.render.bind(this);\n\n    // Bind event handlers\n    this._onFocus = this._onFocus.bind(this);\n    this._onBlur = this._onBlur.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onClick = this._onClick.bind(this);\n    this._onTouchMove = this._onTouchMove.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n    this._onMouseDown = this._onMouseDown.bind(this);\n    this._onMouseOver = this._onMouseOver.bind(this);\n\n    // Monitor touch taps/scrolls\n    this.wasTap = true;\n\n    // Cutting the mustard\n    const cuttingTheMustard = 'classList' in document.documentElement;\n    if (!cuttingTheMustard && !this.config.silent) {\n      console.error('Choices: Your browser doesn\\'t support Choices');\n    }\n\n    const canInit = isElement(this.passedElement) && this.isValidElementType;\n\n    if (canInit) {\n      // If element has already been initialised with Choices\n      if (this.passedElement.getAttribute('data-choice') === 'active') {\n        return false;\n      }\n\n      // Let's go\n      this.init();\n    } else if (!this.config.silent) {\n      console.error('Incompatible input passed');\n    }\n  }\n\n  /* ========================================\n  =            Public functions            =\n  ======================================== */\n\n  /**\n   * Initialise Choices\n   * @return\n   * @public\n   */\n  init() {\n    if (this.initialised) {\n      return;\n    }\n\n    // Set initialise flag\n    this.initialised = true;\n    // Create required elements\n    this._createTemplates();\n    // Generate input markup\n    this._createInput();\n    // Subscribe store to render method\n    this.store.subscribe(this.render);\n    // Render any items\n    this.render();\n    // Trigger event listeners\n    this._addEventListeners();\n\n    const callback = this.config.callbackOnInit;\n    // Run callback if it is a function\n    if (callback && isType('Function', callback)) {\n      callback.call(this);\n    }\n  }\n\n  /**\n   * Destroy Choices and nullify values\n   * @return\n   * @public\n   */\n  destroy() {\n    if (!this.initialised) {\n      return;\n    }\n\n    // Remove all event listeners\n    this._removeEventListeners();\n\n    // Reinstate passed element\n    this.passedElement.classList.remove(\n      this.config.classNames.input,\n      this.config.classNames.hiddenState,\n    );\n    this.passedElement.removeAttribute('tabindex');\n\n    // Recover original styles if any\n    const origStyle = this.passedElement.getAttribute('data-choice-orig-style');\n    if (origStyle) {\n      this.passedElement.removeAttribute('data-choice-orig-style');\n      this.passedElement.setAttribute('style', origStyle);\n    } else {\n      this.passedElement.removeAttribute('style');\n    }\n    this.passedElement.removeAttribute('aria-hidden');\n    this.passedElement.removeAttribute('data-choice');\n\n    // Re-assign values - this is weird, I know\n    this.passedElement.value = this.passedElement.value;\n\n    // Move passed element back to original position\n    this.containerOuter.element.parentNode.insertBefore(\n      this.passedElement,\n      this.containerOuter.element,\n    );\n\n    // Remove added elements\n    this.containerOuter.element.parentNode.removeChild(this.containerOuter.element);\n\n    // Clear data store\n    this.clearStore();\n\n    // Nullify instance-specific data\n    this.config.templates = null;\n\n    // Uninitialise\n    this.initialised = false;\n  }\n\n  /**\n   * Render group choices into a DOM fragment and append to choice list\n   * @param  {Array} groups    Groups to add to list\n   * @param  {Array} choices   Choices to add to groups\n   * @param  {DocumentFragment} fragment Fragment to add groups and options to (optional)\n   * @return {DocumentFragment} Populated options fragment\n   * @private\n   */\n  renderGroups(groups, choices, fragment) {\n    const groupFragment = fragment || document.createDocumentFragment();\n    const filter = this.config.sortFilter;\n\n    // If sorting is enabled, filter groups\n    if (this.config.shouldSort) {\n      groups.sort(filter);\n    }\n\n    groups.forEach((group) => {\n      // Grab options that are children of this group\n      const groupChoices = choices.filter((choice) => {\n        if (this.isSelectOneElement) {\n          return choice.groupId === group.id;\n        }\n        return choice.groupId === group.id && (this.config.renderSelectedChoices === 'always' || !choice.selected);\n      });\n\n      if (groupChoices.length >= 1) {\n        const dropdownGroup = this._getTemplate('choiceGroup', group);\n        groupFragment.appendChild(dropdownGroup);\n        this.renderChoices(groupChoices, groupFragment, true);\n      }\n    });\n\n    return groupFragment;\n  }\n\n  /**\n   * Render choices into a DOM fragment and append to choice list\n   * @param  {Array} choices    Choices to add to list\n   * @param  {DocumentFragment} fragment Fragment to add choices to (optional)\n   * @return {DocumentFragment} Populated choices fragment\n   * @private\n   */\n  renderChoices(choices, fragment, withinGroup = false) {\n    // Create a fragment to store our list items (so we don't have to update the DOM for each item)\n    const choicesFragment = fragment || document.createDocumentFragment();\n    const { renderSelectedChoices, searchResultLimit, renderChoiceLimit } = this.config;\n    const filter = this.isSearching ? sortByScore : this.config.sortFilter;\n    const appendChoice = (choice) => {\n      const shouldRender = renderSelectedChoices === 'auto' ?\n        (this.isSelectOneElement || !choice.selected) :\n        true;\n      if (shouldRender) {\n        const dropdownItem = this._getTemplate('choice', choice);\n        choicesFragment.appendChild(dropdownItem);\n      }\n    };\n\n    let rendererableChoices = choices;\n\n    if (renderSelectedChoices === 'auto' && !this.isSelectOneElement) {\n      rendererableChoices = choices.filter(choice => !choice.selected);\n    }\n\n    // Split array into placeholders and \"normal\" choices\n    const { placeholderChoices, normalChoices } = rendererableChoices.reduce((acc, choice) => {\n      if (choice.placeholder) {\n        acc.placeholderChoices.push(choice);\n      } else {\n        acc.normalChoices.push(choice);\n      }\n      return acc;\n    }, { placeholderChoices: [], normalChoices: [] });\n\n    // If sorting is enabled or the user is searching, filter choices\n    if (this.config.shouldSort || this.isSearching) {\n      normalChoices.sort(filter);\n    }\n\n    let choiceLimit = rendererableChoices.length;\n\n    // Prepend placeholeder\n    const sortedChoices = [...placeholderChoices, ...normalChoices];\n\n    if (this.isSearching) {\n      choiceLimit = searchResultLimit;\n    } else if (renderChoiceLimit > 0 && !withinGroup) {\n      choiceLimit = renderChoiceLimit;\n    }\n\n    // Add each choice to dropdown within range\n    for (let i = 0; i < choiceLimit; i += 1) {\n      if (sortedChoices[i]) {\n        appendChoice(sortedChoices[i]);\n      }\n    }\n\n    return choicesFragment;\n  }\n\n  /**\n   * Render items into a DOM fragment and append to items list\n   * @param  {Array} items    Items to add to list\n   * @param  {DocumentFragment} [fragment] Fragment to add items to (optional)\n   * @return\n   * @private\n   */\n  renderItems(items, fragment = null) {\n    // Create fragment to add elements to\n    const itemListFragment = fragment || document.createDocumentFragment();\n\n    // If sorting is enabled, filter items\n    if (this.config.shouldSortItems && !this.isSelectOneElement) {\n      items.sort(this.config.sortFilter);\n    }\n\n    if (this.isTextElement) {\n      // Simplify store data to just values\n      const itemsFiltered = this.store.getItemsReducedToValues(items);\n      const itemsFilteredString = itemsFiltered.join(this.config.delimiter);\n      // Update the value of the hidden input\n      this.passedElement.setAttribute('value', itemsFilteredString);\n      this.passedElement.value = itemsFilteredString;\n    } else {\n      const selectedOptionsFragment = document.createDocumentFragment();\n\n      // Add each list item to list\n      items.forEach((item) => {\n        // Create a standard select option\n        const option = this._getTemplate('option', item);\n        // Append it to fragment\n        selectedOptionsFragment.appendChild(option);\n      });\n\n      // Update selected choices\n      this.passedElement.innerHTML = '';\n      this.passedElement.appendChild(selectedOptionsFragment);\n    }\n\n    // Add each list item to list\n    items.forEach((item) => {\n      // Create new list element\n      const listItem = this._getTemplate('item', item);\n      // Append it to list\n      itemListFragment.appendChild(listItem);\n    });\n\n    return itemListFragment;\n  }\n\n  /**\n   * Render DOM with values\n   * @return\n   * @private\n   */\n  render() {\n    this.currentState = this.store.getState();\n\n    // Only render if our state has actually changed\n    if (this.currentState !== this.prevState) {\n      // Choices\n      if (\n        (this.currentState.choices !== this.prevState.choices ||\n        this.currentState.groups !== this.prevState.groups ||\n        this.currentState.items !== this.prevState.items) &&\n        this.isSelectElement\n      ) {\n          // Get active groups/choices\n        const activeGroups = this.store.getGroupsFilteredByActive();\n        const activeChoices = this.store.getChoicesFilteredByActive();\n\n        let choiceListFragment = document.createDocumentFragment();\n\n          // Clear choices\n        this.choiceList.clear();\n\n          // Scroll back to top of choices list\n        if (this.config.resetScrollPosition) {\n          this.choiceList.scrollTo(0);\n        }\n\n          // If we have grouped options\n        if (activeGroups.length >= 1 && this.isSearching !== true) {\n          choiceListFragment = this.renderGroups(activeGroups, activeChoices, choiceListFragment);\n        } else if (activeChoices.length >= 1) {\n          choiceListFragment = this.renderChoices(activeChoices, choiceListFragment);\n        }\n\n        const activeItems = this.store.getItemsFilteredByActive();\n        const canAddItem = this._canAddItem(activeItems, this.input.getValue());\n\n          // If we have choices to show\n        if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {\n            // ...and we can select them\n          if (canAddItem.response) {\n              // ...append them and highlight the first choice\n            this.choiceList.append(choiceListFragment);\n            this._highlightChoice();\n          } else {\n              // ...otherwise show a notice\n            this.choiceList.append(this._getTemplate('notice', canAddItem.notice));\n          }\n        } else {\n            // Otherwise show a notice\n          let dropdownItem;\n          let notice;\n\n          if (this.isSearching) {\n            notice = isType('Function', this.config.noResultsText) ?\n                this.config.noResultsText() :\n                this.config.noResultsText;\n\n            dropdownItem = this._getTemplate('notice', notice, 'no-results');\n          } else {\n            notice = isType('Function', this.config.noChoicesText) ?\n                this.config.noChoicesText() :\n                this.config.noChoicesText;\n\n            dropdownItem = this._getTemplate('notice', notice, 'no-choices');\n          }\n\n          this.choiceList.append(dropdownItem);\n        }\n      }\n\n      // Items\n      if (this.currentState.items !== this.prevState.items) {\n        // Get active items (items that can be selected)\n        const activeItems = this.store.getItemsFilteredByActive();\n\n        // Clear list\n        this.itemList.clear();\n\n        if (activeItems && activeItems.length) {\n          // Create a fragment to store our list items\n          // (so we don't have to update the DOM for each item)\n          const itemListFragment = this.renderItems(activeItems);\n\n          // If we have items to add\n          if (itemListFragment.childNodes) {\n            // Update list\n            this.itemList.append(itemListFragment);\n          }\n        }\n      }\n\n      this.prevState = this.currentState;\n    }\n  }\n\n  /**\n   * Select item (a selected item can be deleted)\n   * @param  {Element} item Element to select\n   * @param  {Boolean} [runEvent=true] Whether to trigger 'highlightItem' event\n   * @return {Object} Class instance\n   * @public\n   */\n  highlightItem(item, runEvent = true) {\n    if (!item) {\n      return this;\n    }\n\n    const id = item.id;\n    const groupId = item.groupId;\n    const group = groupId >= 0 ? this.store.getGroupById(groupId) : null;\n\n    this.store.dispatch(\n      highlightItem(id, true),\n    );\n\n    if (runEvent) {\n      const eventResponse = {\n        id,\n        value: item.value,\n        label: item.label,\n      };\n\n      if (group && group.value) {\n        eventResponse.groupValue = group.value;\n      }\n\n      triggerEvent(this.passedElement, 'highlightItem', eventResponse);\n    }\n\n    return this;\n  }\n\n  /**\n   * Deselect item\n   * @param  {Element} item Element to de-select\n   * @return {Object} Class instance\n   * @public\n   */\n  unhighlightItem(item) {\n    if (!item) {\n      return this;\n    }\n\n    const id = item.id;\n    const groupId = item.groupId;\n    const group = groupId >= 0 ? this.store.getGroupById(groupId) : null;\n    const eventResponse = {\n      id,\n      value: item.value,\n      label: item.label,\n    };\n\n    if (group && group.value) {\n      eventResponse.groupValue = group.value;\n    }\n\n    this.store.dispatch(\n      highlightItem(id, false),\n    );\n\n    triggerEvent(this.passedElement, 'highlightItem', eventResponse);\n\n    return this;\n  }\n\n  /**\n   * Highlight items within store\n   * @return {Object} Class instance\n   * @public\n   */\n  highlightAll() {\n    const items = this.store.getItems();\n    items.forEach(item => this.highlightItem(item));\n    return this;\n  }\n\n  /**\n   * Deselect items within store\n   * @return {Object} Class instance\n   * @public\n   */\n  unhighlightAll() {\n    const items = this.store.getItems();\n    items.forEach(item => this.unhighlightItem(item));\n    return this;\n  }\n\n  /**\n   * Remove an item from the store by its value\n   * @param  {String} value Value to search for\n   * @return {Object} Class instance\n   * @public\n   */\n  removeItemsByValue(value) {\n    if (!value || !isType('String', value)) {\n      return this;\n    }\n\n    const items = this.store.getItemsFilteredByActive();\n\n    items.forEach((item) => {\n      if (item.value === value) {\n        this._removeItem(item);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove all items from store array\n   * @note Removed items are soft deleted\n   * @param  {Number} excludedId Optionally exclude item by ID\n   * @return {Object} Class instance\n   * @public\n   */\n  removeActiveItems(excludedId) {\n    const items = this.store.getItemsFilteredByActive();\n\n    items.forEach((item) => {\n      if (item.active && excludedId !== item.id) {\n        this._removeItem(item);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove all selected items from store\n   * @note Removed items are soft deleted\n   * @return {Object} Class instance\n   * @public\n   */\n  removeHighlightedItems(runEvent = false) {\n    const items = this.store.getItemsFilteredByActive();\n\n    items.forEach((item) => {\n      if (item.highlighted && item.active) {\n        this._removeItem(item);\n        // If this action was performed by the user\n        // trigger the event\n        if (runEvent) {\n          this._triggerChange(item.value);\n        }\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Show dropdown to user by adding active state class\n   * @return {Object} Class instance\n   * @public\n   */\n  showDropdown(focusInput = false) {\n    if (this.dropdown.isActive) {\n      return this;\n    }\n\n    this.containerOuter.open(this.dropdown.getVerticalPos());\n    this.dropdown.show();\n    this.input.activate(focusInput);\n\n    triggerEvent(this.passedElement, 'showDropdown', {});\n    return this;\n  }\n\n  /**\n   * Hide dropdown from user\n   * @return {Object} Class instance\n   * @public\n   */\n  hideDropdown(blurInput = false) {\n    if (!this.dropdown.isActive) {\n      return this;\n    }\n\n    this.containerOuter.close();\n    this.dropdown.hide();\n    this.input.deactivate(blurInput);\n\n    triggerEvent(this.passedElement, 'hideDropdown', {});\n    return this;\n  }\n\n  /**\n   * Determine whether to hide or show dropdown based on its current state\n   * @return {Object} Class instance\n   * @public\n   */\n  toggleDropdown() {\n    if (this.dropdown.isActive) {\n      this.hideDropdown();\n    } else {\n      this.showDropdown(true);\n    }\n\n    return this;\n  }\n\n  /**\n   * Get value(s) of input (i.e. inputted items (text) or selected choices (select))\n   * @param {Boolean} valueOnly Get only values of selected items, otherwise return selected items\n   * @return {Array/String} selected value (select-one) or\n   *                        array of selected items (inputs & select-multiple)\n   * @public\n   */\n  getValue(valueOnly = false) {\n    const items = this.store.getItemsFilteredByActive();\n    const selectedItems = [];\n\n    items.forEach((item) => {\n      const itemValue = valueOnly ? item.value : item;\n      if (this.isTextElement || item.active) {\n        selectedItems.push(itemValue);\n      }\n    });\n\n    return this.isSelectOneElement ? selectedItems[0] : selectedItems;\n  }\n\n  /**\n   * Set value of input. If the input is a select box, a choice will\n   * be created and selected otherwise an item will created directly.\n   * @param  {Array}   args  Array of value objects or value strings\n   * @return {Object} Class instance\n   * @public\n   */\n  setValue(args) {\n    if (!this.initialised) {\n      return this;\n    }\n\n    // Convert args to an iterable array\n    const values = [...args];\n    const handleValue = (item) => {\n      const itemType = getType(item).toLowerCase();\n      const handleType = {\n        object: () => {\n          if (!item.value) {\n            return;\n          }\n\n          // If we are dealing with a select input, we need to create an option first\n          // that is then selected. For text inputs we can just add items normally.\n          if (!this.isTextElement) {\n            this._addChoice(\n              item.value,\n              item.label,\n              true,\n              false, -1,\n              item.customProperties,\n              item.placeholder,\n            );\n          } else {\n            this._addItem(\n              item.value,\n              item.label,\n              item.id,\n              undefined,\n              item.customProperties,\n              item.placeholder,\n            );\n          }\n        },\n        string: () => {\n          if (!this.isTextElement) {\n            this._addChoice(\n              item,\n              item,\n              true,\n              false, -1,\n              null,\n            );\n          } else {\n            this._addItem(item);\n          }\n        },\n      };\n\n      handleType[itemType]();\n    };\n\n    values.forEach(value => handleValue(value));\n\n    return this;\n  }\n\n  /**\n   * Select value of select box via the value of an existing choice\n   * @param {Array/String} value An array of strings of a single string\n   * @return {Object} Class instance\n   * @public\n   */\n  setValueByChoice(value) {\n    if (this.isTextElement) {\n      return this;\n    }\n\n    const choices = this.store.getChoices();\n    // If only one value has been passed, convert to array\n    const choiceValue = isType('Array', value) ? value : [value];\n\n    // Loop through each value and\n    choiceValue.forEach((val) => {\n      // Check 'value' property exists and the choice isn't already selected\n      const foundChoice = choices.find(choice => choice.value === val);\n\n      if (foundChoice) {\n        if (!foundChoice.selected) {\n          this._addItem(\n            foundChoice.value,\n            foundChoice.label,\n            foundChoice.id,\n            foundChoice.groupId,\n            foundChoice.customProperties,\n            foundChoice.placeholder,\n            foundChoice.keyCode,\n          );\n        } else if (!this.config.silent) {\n          console.warn('Attempting to select choice already selected');\n        }\n      } else if (!this.config.silent) {\n        console.warn('Attempting to select choice that does not exist');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Direct populate choices\n   * @param  {Array} choices - Choices to insert\n   * @param  {String} value - Name of 'value' property\n   * @param  {String} label - Name of 'label' property\n   * @param  {Boolean} replaceChoices Whether existing choices should be removed\n   * @return {Object} Class instance\n   * @public\n   */\n  setChoices(choices, value, label, replaceChoices = false) {\n    if (\n      !this.initialised ||\n      !this.isSelectElement ||\n      !isType('Array', choices) ||\n      !value\n    ) {\n      return this;\n    }\n\n    // Clear choices if needed\n    if (replaceChoices) {\n      this._clearChoices();\n    }\n\n    // Add choices if passed\n    if (choices && choices.length) {\n      this.containerOuter.removeLoadingState();\n\n      choices.forEach((result) => {\n        if (result.choices) {\n          this._addGroup(\n            result,\n            (result.id || null),\n            value,\n            label,\n          );\n        } else {\n          this._addChoice(\n            result[value],\n            result[label],\n            result.selected,\n            result.disabled,\n            undefined,\n            result.customProperties,\n            result.placeholder,\n          );\n        }\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Clear items,choices and groups\n   * @note Hard delete\n   * @return {Object} Class instance\n   * @public\n   */\n  clearStore() {\n    this.store.dispatch(clearAll());\n    return this;\n  }\n\n  /**\n   * Set value of input to blank\n   * @return {Object} Class instance\n   * @public\n   */\n  clearInput() {\n    const shouldSetInputWidth = !this.isSelectOneElement;\n    this.input.clear(shouldSetInputWidth);\n\n    if (!this.isTextElement && this.config.searchEnabled) {\n      this.isSearching = false;\n      this.store.dispatch(activateChoices(true));\n    }\n\n    return this;\n  }\n\n  /**\n   * Enable interaction with Choices\n   * @return {Object} Class instance\n   */\n  enable() {\n    if (!this.initialised) {\n      return this;\n    }\n\n    this.passedElement.disabled = false;\n\n    if (this.containerOuter.isDisabled) {\n      this._addEventListeners();\n      this.passedElement.removeAttribute('disabled');\n      this.input.enable();\n      this.containerOuter.enable();\n    }\n\n    return this;\n  }\n\n  /**\n   * Disable interaction with Choices\n   * @return {Object} Class instance\n   * @public\n   */\n  disable() {\n    if (!this.initialised) {\n      return this;\n    }\n\n    this.passedElement.disabled = true;\n\n    if (!this.containerOuter.isDisabled) {\n      this._removeEventListeners();\n      this.passedElement.setAttribute('disabled', '');\n      this.input.disable();\n      this.containerOuter.disable();\n    }\n\n    return this;\n  }\n\n  /**\n   * Populate options via ajax callback\n   * @param  {Function} fn Function that actually makes an AJAX request\n   * @return {Object} Class instance\n   * @public\n   */\n  ajax(fn) {\n    if (!this.initialised || !this.isSelectElement) {\n      return this;\n    }\n\n    // Show loading text\n    requestAnimationFrame(() => this._handleLoadingState(true));\n    // Run callback\n    fn(this._ajaxCallback());\n\n    return this;\n  }\n\n  /* =====  End of Public functions  ====== */\n\n  /* =============================================\n  =                Private functions            =\n  ============================================= */\n\n  /**\n   * Call change callback\n   * @param  {String} value - last added/deleted/selected value\n   * @return\n   * @private\n   */\n  _triggerChange(value) {\n    if (!value) {\n      return;\n    }\n\n    triggerEvent(this.passedElement, 'change', {\n      value,\n    });\n  }\n\n  /**\n   * Process enter/click of an item button\n   * @param {Array} activeItems The currently active items\n   * @param  {Element} element Button being interacted with\n   * @return\n   * @private\n   */\n  _handleButtonAction(activeItems, element) {\n    if (\n      !activeItems ||\n      !element ||\n      !this.config.removeItems ||\n      !this.config.removeItemButton\n    ) {\n      return;\n    }\n\n    const itemId = element.parentNode.getAttribute('data-id');\n    const itemToRemove = activeItems.find(item => item.id === parseInt(itemId, 10));\n\n   // Remove item associated with button\n    this._removeItem(itemToRemove);\n    this._triggerChange(itemToRemove.value);\n\n    if (this.isSelectOneElement) {\n      this._selectPlaceholderChoice();\n    }\n  }\n\n  /**\n   * Select placeholder choice\n   */\n  _selectPlaceholderChoice() {\n    const placeholderChoice = this.store.getPlaceholderChoice();\n\n    if (placeholderChoice) {\n      this._addItem(\n        placeholderChoice.value,\n        placeholderChoice.label,\n        placeholderChoice.id,\n        placeholderChoice.groupId,\n        null,\n        placeholderChoice.placeholder,\n      );\n      this._triggerChange(placeholderChoice.value);\n    }\n  }\n\n  /**\n   * Process click of an item\n   * @param {Array} activeItems The currently active items\n   * @param  {Element} element Item being interacted with\n   * @param  {Boolean} hasShiftKey Whether the user has the shift key active\n   * @return\n   * @private\n   */\n  _handleItemAction(activeItems, element, hasShiftKey = false) {\n    if (\n      !activeItems ||\n      !element ||\n      !this.config.removeItems ||\n      this.isSelectOneElement\n    ) {\n      return;\n    }\n\n    const passedId = element.getAttribute('data-id');\n\n    // We only want to select one item with a click\n    // so we deselect any items that aren't the target\n    // unless shift is being pressed\n    activeItems.forEach((item) => {\n      if (item.id === parseInt(passedId, 10) && !item.highlighted) {\n        this.highlightItem(item);\n      } else if (!hasShiftKey && item.highlighted) {\n        this.unhighlightItem(item);\n      }\n    });\n\n    // Focus input as without focus, a user cannot do anything with a\n    // highlighted item\n    this.input.focus();\n  }\n\n  /**\n   * Process click of a choice\n   * @param {Array} activeItems The currently active items\n   * @param  {Element} element Choice being interacted with\n   * @return\n   */\n  _handleChoiceAction(activeItems, element) {\n    if (!activeItems || !element) {\n      return;\n    }\n\n    // If we are clicking on an option\n    const id = element.getAttribute('data-id');\n    const choice = this.store.getChoiceById(id);\n    const passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;\n    const hasActiveDropdown = this.dropdown.isActive;\n\n    // Update choice keyCode\n    choice.keyCode = passedKeyCode;\n\n    triggerEvent(this.passedElement, 'choice', {\n      choice,\n    });\n\n    if (choice && !choice.selected && !choice.disabled) {\n      const canAddItem = this._canAddItem(activeItems, choice.value);\n\n      if (canAddItem.response) {\n        this._addItem(\n          choice.value,\n          choice.label,\n          choice.id,\n          choice.groupId,\n          choice.customProperties,\n          choice.placeholder,\n          choice.keyCode,\n        );\n        this._triggerChange(choice.value);\n      }\n    }\n\n    this.clearInput();\n\n    // We wont to close the dropdown if we are dealing with a single select box\n    if (hasActiveDropdown && this.isSelectOneElement) {\n      this.hideDropdown();\n      this.containerOuter.focus();\n    }\n  }\n\n  /**\n   * Process back space event\n   * @param  {Array} activeItems items\n   * @return\n   * @private\n   */\n  _handleBackspace(activeItems) {\n    if (!this.config.removeItems || !activeItems) {\n      return;\n    }\n\n    const lastItem = activeItems[activeItems.length - 1];\n    const hasHighlightedItems = activeItems.some(item => item.highlighted);\n\n    // If editing the last item is allowed and there are not other selected items,\n    // we can edit the item value. Otherwise if we can remove items, remove all selected items\n    if (this.config.editItems && !hasHighlightedItems && lastItem) {\n      this.input.setValue(lastItem.value);\n      this.input.setWidth();\n      this._removeItem(lastItem);\n      this._triggerChange(lastItem.value);\n    } else {\n      if (!hasHighlightedItems) {\n        this.highlightItem(lastItem, false);\n      }\n      this.removeHighlightedItems(true);\n    }\n  }\n\n  /**\n   * Validates whether an item can be added by a user\n   * @param {Array} activeItems The currently active items\n   * @param  {String} value     Value of item to add\n   * @return {Object}           Response: Whether user can add item\n   *                            Notice: Notice show in dropdown\n   */\n  _canAddItem(activeItems, value) {\n    let canAddItem = true;\n    let notice = isType('Function', this.config.addItemText) ?\n      this.config.addItemText(value) :\n      this.config.addItemText;\n\n    if (this.isSelectMultipleElement || this.isTextElement) {\n      if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {\n        // If there is a max entry limit and we have reached that limit\n        // don't update\n        canAddItem = false;\n        notice = isType('Function', this.config.maxItemText) ?\n          this.config.maxItemText(this.config.maxItemCount) :\n          this.config.maxItemText;\n      }\n    }\n\n    if (this.isTextElement && this.config.addItems && canAddItem && this.config.regexFilter) {\n      // If a user has supplied a regular expression filter\n      // determine whether we can update based on whether\n      // our regular expression passes\n      canAddItem = regexFilter(value, this.config.regexFilter);\n    }\n\n    // If no duplicates are allowed, and the value already exists\n    // in the array\n    const isUnique = !activeItems.some((item) => {\n      if (isType('String', value)) {\n        return item.value === value.trim();\n      }\n\n      return item.value === value;\n    });\n\n    if (!isUnique &&\n      !this.config.duplicateItems &&\n      !this.isSelectOneElement &&\n      canAddItem\n    ) {\n      canAddItem = false;\n      notice = isType('Function', this.config.uniqueItemText) ?\n        this.config.uniqueItemText(value) :\n        this.config.uniqueItemText;\n    }\n\n    return {\n      response: canAddItem,\n      notice,\n    };\n  }\n\n  /**\n   * Apply or remove a loading state to the component.\n   * @param {Boolean} isLoading default value set to 'true'.\n   * @return\n   * @private\n   */\n  _handleLoadingState(isLoading = true) {\n    let placeholderItem = this.itemList.getChild(`.${this.config.classNames.placeholder}`);\n    if (isLoading) {\n      this.containerOuter.addLoadingState();\n      if (this.isSelectOneElement) {\n        if (!placeholderItem) {\n          placeholderItem = this._getTemplate('placeholder', this.config.loadingText);\n          this.itemList.append(placeholderItem);\n        } else {\n          placeholderItem.innerHTML = this.config.loadingText;\n        }\n      } else {\n        this.input.setPlaceholder(this.config.loadingText);\n      }\n    } else {\n      this.containerOuter.removeLoadingState();\n\n      if (this.isSelectOneElement) {\n        placeholderItem.innerHTML = (this.placeholder || '');\n      } else {\n        this.input.setPlaceholder(this.placeholder || '');\n      }\n    }\n  }\n\n  /**\n   * Retrieve the callback used to populate component's choices in an async way.\n   * @returns {Function} The callback as a function.\n   * @private\n   */\n  _ajaxCallback() {\n    return (results, value, label) => {\n      if (!results || !value) {\n        return;\n      }\n\n      const parsedResults = isType('Object', results) ? [results] : results;\n\n      if (parsedResults && isType('Array', parsedResults) && parsedResults.length) {\n        // Remove loading states/text\n        this._handleLoadingState(false);\n        // Add each result as a choice\n        parsedResults.forEach((result) => {\n          if (result.choices) {\n            const groupId = (result.id || null);\n            this._addGroup(\n              result,\n              groupId,\n              value,\n              label,\n            );\n          } else {\n            this._addChoice(\n              result[value],\n              result[label],\n              result.selected,\n              result.disabled,\n              undefined,\n              result.customProperties,\n              result.placeholder,\n            );\n          }\n        });\n\n        if (this.isSelectOneElement) {\n          this._selectPlaceholderChoice();\n        }\n      } else {\n        // No results, remove loading state\n        this._handleLoadingState(false);\n      }\n    };\n  }\n\n  /**\n   * Filter choices based on search value\n   * @param  {String} value Value to filter by\n   * @return\n   * @private\n   */\n  _searchChoices(value) {\n    const newValue = isType('String', value) ? value.trim() : value;\n    const currentValue = isType('String', this.currentValue) ?\n      this.currentValue.trim() :\n      this.currentValue;\n\n    // If new value matches the desired length and is not the same as the current value with a space\n    if (newValue.length >= 1 && newValue !== `${currentValue} `) {\n      const haystack = this.store.getSearchableChoices();\n      const needle = newValue;\n      const keys = isType('Array', this.config.searchFields) ?\n        this.config.searchFields :\n        [this.config.searchFields];\n      const options = Object.assign(this.config.fuseOptions, { keys });\n      const fuse = new Fuse(haystack, options);\n      const results = fuse.search(needle);\n\n      this.currentValue = newValue;\n      this.highlightPosition = 0;\n      this.isSearching = true;\n      this.store.dispatch(filterChoices(results));\n\n      return results.length;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Determine the action when a user is searching\n   * @param  {String} value Value entered by user\n   * @return\n   * @private\n   */\n  _handleSearch(value) {\n    if (!value || !this.input.isFocussed) {\n      return;\n    }\n\n    const choices = this.store.getChoices();\n    const hasUnactiveChoices = choices.some(option => !option.active);\n\n    // Check that we have a value to search and the input was an alphanumeric character\n    if (value && value.length >= this.config.searchFloor) {\n      const resultCount = this.config.searchChoices ? this._searchChoices(value) : 0;\n      // Trigger search event\n      triggerEvent(this.passedElement, 'search', {\n        value,\n        resultCount,\n      });\n    } else if (hasUnactiveChoices) {\n      // Otherwise reset choices to active\n      this.isSearching = false;\n      this.store.dispatch(activateChoices(true));\n    }\n  }\n\n  /**\n   * Trigger event listeners\n   * @return\n   * @private\n   */\n  _addEventListeners() {\n    document.addEventListener('keyup', this._onKeyUp);\n    document.addEventListener('keydown', this._onKeyDown);\n    document.addEventListener('click', this._onClick);\n    document.addEventListener('touchmove', this._onTouchMove);\n    document.addEventListener('touchend', this._onTouchEnd);\n    document.addEventListener('mousedown', this._onMouseDown);\n    document.addEventListener('mouseover', this._onMouseOver);\n\n    if (this.isSelectOneElement) {\n      this.containerOuter.element.addEventListener('focus', this._onFocus);\n      this.containerOuter.element.addEventListener('blur', this._onBlur);\n    }\n\n    this.input.element.addEventListener('focus', this._onFocus);\n    this.input.element.addEventListener('blur', this._onBlur);\n\n    this.input.addEventListeners();\n  }\n\n  /**\n   * Remove event listeners\n   * @return\n   * @private\n   */\n  _removeEventListeners() {\n    document.removeEventListener('keyup', this._onKeyUp);\n    document.removeEventListener('keydown', this._onKeyDown);\n    document.removeEventListener('click', this._onClick);\n    document.removeEventListener('touchmove', this._onTouchMove);\n    document.removeEventListener('touchend', this._onTouchEnd);\n    document.removeEventListener('mousedown', this._onMouseDown);\n    document.removeEventListener('mouseover', this._onMouseOver);\n\n    if (this.isSelectOneElement) {\n      this.containerOuter.element.removeEventListener('focus', this._onFocus);\n      this.containerOuter.element.removeEventListener('blur', this._onBlur);\n    }\n\n    this.input.element.removeEventListener('focus', this._onFocus);\n    this.input.element.removeEventListener('blur', this._onBlur);\n\n    this.input.removeEventListeners();\n  }\n\n  /**\n   * Key down event\n   * @param  {Object} e Event\n   * @return\n   */\n  _onKeyDown(e) {\n    if (e.target !== this.input.element && !this.containerOuter.element.contains(e.target)) {\n      return;\n    }\n\n    const target = e.target;\n    const activeItems = this.store.getItemsFilteredByActive();\n    const hasFocusedInput = this.input.isFocussed;\n    const hasActiveDropdown = this.dropdown.isActive;\n    const hasItems = this.itemList.hasChildren;\n    const keyString = String.fromCharCode(e.keyCode);\n\n    // TO DO: Move into constants file\n    const backKey = 46;\n    const deleteKey = 8;\n    const enterKey = 13;\n    const aKey = 65;\n    const escapeKey = 27;\n    const upKey = 38;\n    const downKey = 40;\n    const pageUpKey = 33;\n    const pageDownKey = 34;\n    const ctrlDownKey = (e.ctrlKey || e.metaKey);\n\n    // If a user is typing and the dropdown is not active\n    if (!this.isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString)) {\n      this.showDropdown(true);\n    }\n\n    this.canSearch = this.config.searchEnabled;\n\n    const onAKey = () => {\n      // If CTRL + A or CMD + A have been pressed and there are items to select\n      if (ctrlDownKey && hasItems) {\n        this.canSearch = false;\n        if (\n          this.config.removeItems &&\n          !this.input.element.value &&\n          this.input.element === document.activeElement\n        ) {\n          // Highlight items\n          this.highlightAll();\n        }\n      }\n    };\n\n    const onEnterKey = () => {\n      // If enter key is pressed and the input has a value\n      if (this.isTextElement && target.value) {\n        const value = this.input.element.value;\n        const canAddItem = this._canAddItem(activeItems, value);\n\n        // All is good, add\n        if (canAddItem.response) {\n          this.hideDropdown();\n          this._addItem(value);\n          this._triggerChange(value);\n          this.clearInput();\n        }\n      }\n\n      if (target.hasAttribute('data-button')) {\n        this._handleButtonAction(activeItems, target);\n        e.preventDefault();\n      }\n\n      if (hasActiveDropdown) {\n        e.preventDefault();\n        const highlighted = this.dropdown.getChild(`.${this.config.classNames.highlightedState}`);\n\n        // If we have a highlighted choice\n        if (highlighted) {\n          // add enter keyCode value\n          if (activeItems[0]) {\n            activeItems[0].keyCode = enterKey;\n          }\n          this._handleChoiceAction(activeItems, highlighted);\n        }\n      } else if (this.isSelectOneElement) {\n        // Open single select dropdown if it's not active\n        this.showDropdown(true);\n        e.preventDefault();\n      }\n    };\n\n    const onEscapeKey = () => {\n      if (hasActiveDropdown) {\n        this.hideDropdown();\n        this.containerOuter.focus();\n      }\n    };\n\n    const onDirectionKey = () => {\n      // If up or down key is pressed, traverse through options\n      if (hasActiveDropdown || this.isSelectOneElement) {\n        // Show dropdown if focus\n        this.showDropdown(true);\n\n        this.canSearch = false;\n\n        const directionInt = e.keyCode === downKey || e.keyCode === pageDownKey ? 1 : -1;\n        const skipKey = e.metaKey || e.keyCode === pageDownKey || e.keyCode === pageUpKey;\n\n        let nextEl;\n        if (skipKey) {\n          if (directionInt > 0) {\n            nextEl = Array.from(\n              this.dropdown.element.querySelectorAll('[data-choice-selectable]'),\n            ).pop();\n          } else {\n            nextEl = this.dropdown.element.querySelector('[data-choice-selectable]');\n          }\n        } else {\n          const currentEl = this.dropdown.element.querySelector(\n            `.${this.config.classNames.highlightedState}`,\n          );\n          if (currentEl) {\n            nextEl = getAdjacentEl(currentEl, '[data-choice-selectable]', directionInt);\n          } else {\n            nextEl = this.dropdown.element.querySelector('[data-choice-selectable]');\n          }\n        }\n\n        if (nextEl) {\n          // We prevent default to stop the cursor moving\n          // when pressing the arrow\n          if (!isScrolledIntoView(nextEl, this.choiceList, directionInt)) {\n            this._scrollToChoice(nextEl, directionInt);\n          }\n          this._highlightChoice(nextEl);\n        }\n\n        // Prevent default to maintain cursor position whilst\n        // traversing dropdown options\n        e.preventDefault();\n      }\n    };\n\n    const onDeleteKey = () => {\n      // If backspace or delete key is pressed and the input has no value\n      if (hasFocusedInput && !e.target.value && !this.isSelectOneElement) {\n        this._handleBackspace(activeItems);\n        e.preventDefault();\n      }\n    };\n\n    // Map keys to key actions\n    const keyDownActions = {\n      [aKey]: onAKey,\n      [enterKey]: onEnterKey,\n      [escapeKey]: onEscapeKey,\n      [upKey]: onDirectionKey,\n      [pageUpKey]: onDirectionKey,\n      [downKey]: onDirectionKey,\n      [pageDownKey]: onDirectionKey,\n      [deleteKey]: onDeleteKey,\n      [backKey]: onDeleteKey,\n    };\n\n    // If keycode has a function, run it\n    if (keyDownActions[e.keyCode]) {\n      keyDownActions[e.keyCode]();\n    }\n  }\n\n  /**\n   * Key up event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onKeyUp(e) {\n    if (e.target !== this.input.element) {\n      return;\n    }\n\n    const value = this.input.element.value;\n    const activeItems = this.store.getItemsFilteredByActive();\n    const canAddItem = this._canAddItem(activeItems, value);\n\n    // We are typing into a text input and have a value, we want to show a dropdown\n    // notice. Otherwise hide the dropdown\n    if (this.isTextElement) {\n      if (value) {\n        if (canAddItem.notice) {\n          const dropdownItem = this._getTemplate('notice', canAddItem.notice);\n          this.dropdown.element.innerHTML = dropdownItem.outerHTML;\n        }\n\n        if (canAddItem.response === true) {\n          this.showDropdown();\n        } else if (!canAddItem.notice) {\n          this.hideDropdown();\n        }\n      } else {\n        this.hideDropdown();\n      }\n    } else {\n      const backKey = 46;\n      const deleteKey = 8;\n\n      // If user has removed value...\n      if ((e.keyCode === backKey || e.keyCode === deleteKey) && !e.target.value) {\n        // ...and it is a multiple select input, activate choices (if searching)\n        if (!this.isTextElement && this.isSearching) {\n          this.isSearching = false;\n          this.store.dispatch(\n            activateChoices(true),\n          );\n        }\n      } else if (this.canSearch && canAddItem.response) {\n        this._handleSearch(this.input.element.value);\n      }\n    }\n    // Re-establish canSearch value from changes in _onKeyDown\n    this.canSearch = this.config.searchEnabled;\n  }\n\n  /**\n   * Touch move event\n   * @return\n   * @private\n   */\n  _onTouchMove() {\n    if (this.wasTap === true) {\n      this.wasTap = false;\n    }\n  }\n\n  /**\n   * Touch end event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onTouchEnd(e) {\n    const target = (e.target || e.touches[0].target);\n\n    // If a user tapped within our container...\n    if (this.wasTap === true && this.containerOuter.element.contains(target)) {\n      // ...and we aren't dealing with a single select box, show dropdown/focus input\n      if (\n        (target === this.containerOuter.element || target === this.containerInner.element) &&\n        !this.isSelectOneElement\n      ) {\n        if (this.isTextElement) {\n          // If text element, we only want to focus the input\n          this.input.focus();\n        } else {\n            // If a select box, we want to show the dropdown\n          this.showDropdown(true);\n        }\n      }\n      // Prevents focus event firing\n      e.stopPropagation();\n    }\n\n    this.wasTap = true;\n  }\n\n  /**\n   * Mouse down event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onMouseDown(e) {\n    const target = e.target;\n\n    // If we have our mouse down on the scrollbar and are on IE11...\n    if (target === this.choiceList && this.isIe11) {\n      this.isScrollingOnIe = true;\n    }\n\n    if (this.containerOuter.element.contains(target) && target !== this.input.element) {\n      const activeItems = this.store.getItemsFilteredByActive();\n      const hasShiftKey = e.shiftKey;\n\n      const buttonTarget = findAncestorByAttrName(target, 'data-button');\n      const itemTarget = findAncestorByAttrName(target, 'data-item');\n      const choiceTarget = findAncestorByAttrName(target, 'data-choice');\n\n      if (buttonTarget) {\n        this._handleButtonAction(activeItems, buttonTarget);\n      } else if (itemTarget) {\n        this._handleItemAction(activeItems, itemTarget, hasShiftKey);\n      } else if (choiceTarget) {\n        this._handleChoiceAction(activeItems, choiceTarget);\n      }\n\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Click event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onClick(e) {\n    const target = e.target;\n    const hasActiveDropdown = this.dropdown.isActive;\n    const activeItems = this.store.getItemsFilteredByActive();\n\n    // If target is something that concerns us\n    if (this.containerOuter.element.contains(target)) {\n      if (!hasActiveDropdown) {\n        if (this.isTextElement) {\n          if (document.activeElement !== this.input.element) {\n            this.input.focus();\n          }\n        } else if (this.canSearch) {\n          this.showDropdown(true);\n        } else {\n          this.showDropdown();\n          this.containerOuter.focus();\n        }\n      } else if (\n        this.isSelectOneElement &&\n        target !== this.input.element &&\n        !this.dropdown.element.contains(target)\n      ) {\n        this.hideDropdown(true);\n      }\n    } else {\n      const hasHighlightedItems = activeItems.some(item => item.highlighted);\n\n      // De-select any highlighted items\n      if (hasHighlightedItems) {\n        this.unhighlightAll();\n      }\n\n      // Remove focus state\n      this.containerOuter.removeFocusState();\n\n      // Close all other dropdowns\n      this.hideDropdown();\n    }\n  }\n\n  /**\n   * Mouse over (hover) event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onMouseOver(e) {\n    // If the dropdown is either the target or one of its children is the target\n    if (\n      (e.target === this.dropdown || this.dropdown.element.contains(e.target)) &&\n      e.target.hasAttribute('data-choice')\n    ) {\n      this._highlightChoice(e.target);\n    }\n  }\n\n  /**\n   * Focus event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onFocus(e) {\n    const target = e.target;\n    // If target is something that concerns us\n    if (this.containerOuter.element.contains(target)) {\n      const focusActions = {\n        text: () => {\n          if (target === this.input.element) {\n            this.containerOuter.addFocusState();\n          }\n        },\n        'select-one': () => {\n          this.containerOuter.addFocusState();\n          if (target === this.input.element) {\n            // Show dropdown if it isn't already showing\n            this.showDropdown();\n          }\n        },\n        'select-multiple': () => {\n          if (target === this.input.element) {\n            // If element is a select box, the focused element is the container and the dropdown\n            // isn't already open, focus and show dropdown\n            this.containerOuter.addFocusState();\n            this.showDropdown(true);\n          }\n        },\n      };\n\n      focusActions[this.passedElement.type]();\n    }\n  }\n\n  /**\n   * Blur event\n   * @param  {Object} e Event\n   * @return\n   * @private\n   */\n  _onBlur(e) {\n    const target = e.target;\n    // If target is something that concerns us\n    if (this.containerOuter.element.contains(target) && !this.isScrollingOnIe) {\n      const activeItems = this.store.getItemsFilteredByActive();\n      const hasHighlightedItems = activeItems.some(item => item.highlighted);\n      const blurActions = {\n        text: () => {\n          if (target === this.input.element) {\n            // Remove the focus state\n            this.containerOuter.removeFocusState();\n            // De-select any highlighted items\n            if (hasHighlightedItems) {\n              this.unhighlightAll();\n            }\n            this.hideDropdown();\n          }\n        },\n        'select-one': () => {\n          this.containerOuter.removeFocusState();\n          if (target === this.containerOuter.element) {\n            // Hide dropdown if it is showing\n            if (!this.canSearch) {\n              this.hideDropdown();\n            }\n          }\n          if (target === this.input.element) {\n            // Hide dropdown if it is showing\n            this.hideDropdown();\n          }\n        },\n        'select-multiple': () => {\n          if (target === this.input.element) {\n            // Remove the focus state\n            this.containerOuter.removeFocusState();\n            this.hideDropdown();\n            // De-select any highlighted items\n            if (hasHighlightedItems) {\n              this.unhighlightAll();\n            }\n          }\n        },\n      };\n\n      blurActions[this.passedElement.type]();\n    } else {\n      // On IE11, clicking the scollbar blurs our input and thus\n      // closes the dropdown. To stop this, we refocus our input\n      // if we know we are on IE *and* are scrolling.\n      this.isScrollingOnIe = false;\n      this.input.element.focus();\n    }\n  }\n\n  /**\n   * Scroll to an option element\n   * @param  {HTMLElement} choice  Option to scroll to\n   * @param  {Number} direction  Whether option is above or below\n   * @return\n   * @private\n   */\n  _scrollToChoice(choice, direction) {\n    if (!choice) {\n      return;\n    }\n\n    const dropdownHeight = this.choiceList.height;\n    const choiceHeight = choice.offsetHeight;\n    // Distance from bottom of element to top of parent\n    const choicePos = choice.offsetTop + choiceHeight;\n    // Scroll position of dropdown\n    const containerScrollPos = this.choiceList.scrollPos + dropdownHeight;\n    // Difference between the choice and scroll position\n    const endPoint = direction > 0 ? (\n        (this.choiceList.scrollPos + choicePos) - containerScrollPos) :\n      choice.offsetTop;\n\n    const animateScroll = () => {\n      const strength = 4;\n      const choiceListScrollTop = this.choiceList.scrollPos;\n      let continueAnimation = false;\n      let easing;\n      let distance;\n\n      if (direction > 0) {\n        easing = (endPoint - choiceListScrollTop) / strength;\n        distance = easing > 1 ? easing : 1;\n\n        this.choiceList.scrollTo(choiceListScrollTop + distance);\n        if (choiceListScrollTop < endPoint) {\n          continueAnimation = true;\n        }\n      } else {\n        easing = (choiceListScrollTop - endPoint) / strength;\n        distance = easing > 1 ? easing : 1;\n\n        this.choiceList.scrollTo(choiceListScrollTop - distance);\n        if (choiceListScrollTop > endPoint) {\n          continueAnimation = true;\n        }\n      }\n\n      if (continueAnimation) {\n        requestAnimationFrame((time) => {\n          animateScroll(time, endPoint, direction);\n        });\n      }\n    };\n\n    requestAnimationFrame((time) => {\n      animateScroll(time, endPoint, direction);\n    });\n  }\n\n  /**\n   * Highlight choice\n   * @param  {HTMLElement} [el] Element to highlight\n   * @return\n   * @private\n   */\n  _highlightChoice(el = null) {\n    // Highlight first element in dropdown\n    const choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));\n    let passedEl = el;\n\n    if (choices && choices.length) {\n      const highlightedChoices = Array.from(\n        this.dropdown.element.querySelectorAll(`.${this.config.classNames.highlightedState}`),\n      );\n      const hasActiveDropdown = this.dropdown.isActive;\n\n      // Remove any highlighted choices\n      highlightedChoices.forEach((choice) => {\n        choice.classList.remove(this.config.classNames.highlightedState);\n        choice.setAttribute('aria-selected', 'false');\n      });\n\n      if (passedEl) {\n        this.highlightPosition = choices.indexOf(passedEl);\n      } else {\n        // Highlight choice based on last known highlight location\n        if (choices.length > this.highlightPosition) {\n          // If we have an option to highlight\n          passedEl = choices[this.highlightPosition];\n        } else {\n          // Otherwise highlight the option before\n          passedEl = choices[choices.length - 1];\n        }\n\n        if (!passedEl) {\n          passedEl = choices[0];\n        }\n      }\n\n      // Highlight given option, and set accessiblity attributes\n      passedEl.classList.add(this.config.classNames.highlightedState);\n      passedEl.setAttribute('aria-selected', 'true');\n\n      if (hasActiveDropdown) {\n        // IE11 ignores aria-label and blocks virtual keyboard\n        // if aria-activedescendant is set without a dropdown\n        this.input.setActiveDescendant(passedEl.id);\n        this.containerOuter.setActiveDescendant(passedEl.id);\n      }\n    }\n  }\n\n  /**\n   * Add item to store with correct value\n   * @param {String} value Value to add to store\n   * @param {String} [label] Label to add to store\n   * @param {Number} [choiceId=-1] ID of the associated choice that was selected\n   * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group\n   * @param {Object} [customProperties] Object containing user defined properties\n   * @return {Object} Class instance\n   * @public\n   */\n  _addItem(\n    value,\n    label = null,\n    choiceId = -1,\n    groupId = -1,\n    customProperties = null,\n    placeholder = false,\n    keyCode = null,\n  ) {\n    let passedValue = isType('String', value) ? value.trim() : value;\n    const passedKeyCode = keyCode;\n    const items = this.store.getItems();\n    const passedLabel = label || passedValue;\n    const passedOptionId = parseInt(choiceId, 10) || -1;\n\n    // Get group if group ID passed\n    const group = groupId >= 0 ? this.store.getGroupById(groupId) : null;\n\n    // Generate unique id\n    const id = items ? items.length + 1 : 1;\n\n    // If a prepended value has been passed, prepend it\n    if (this.config.prependValue) {\n      passedValue = this.config.prependValue + passedValue.toString();\n    }\n\n    // If an appended value has been passed, append it\n    if (this.config.appendValue) {\n      passedValue += this.config.appendValue.toString();\n    }\n\n    this.store.dispatch(\n      addItem(\n        passedValue,\n        passedLabel,\n        id,\n        passedOptionId,\n        groupId,\n        customProperties,\n        placeholder,\n        passedKeyCode,\n      ),\n    );\n\n    if (this.isSelectOneElement) {\n      this.removeActiveItems(id);\n    }\n\n    // Trigger change event\n    if (group && group.value) {\n      triggerEvent(this.passedElement, 'addItem', {\n        id,\n        value: passedValue,\n        label: passedLabel,\n        groupValue: group.value,\n        keyCode: passedKeyCode,\n      });\n    } else {\n      triggerEvent(this.passedElement, 'addItem', {\n        id,\n        value: passedValue,\n        label: passedLabel,\n        keyCode: passedKeyCode,\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove item from store\n   * @param {Object} item Item to remove\n   * @return {Object} Class instance\n   * @public\n   */\n  _removeItem(item) {\n    if (!item || !isType('Object', item)) {\n      return this;\n    }\n\n    const id = item.id;\n    const value = item.value;\n    const label = item.label;\n    const choiceId = item.choiceId;\n    const groupId = item.groupId;\n    const group = groupId >= 0 ? this.store.getGroupById(groupId) : null;\n\n    this.store.dispatch(\n      removeItem(id, choiceId),\n    );\n\n    if (group && group.value) {\n      triggerEvent(this.passedElement, 'removeItem', {\n        id,\n        value,\n        label,\n        groupValue: group.value,\n      });\n    } else {\n      triggerEvent(this.passedElement, 'removeItem', {\n        id,\n        value,\n        label,\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Add choice to dropdown\n   * @param {String} value Value of choice\n   * @param {String} [label] Label of choice\n   * @param {Boolean} [isSelected=false] Whether choice is selected\n   * @param {Boolean} [isDisabled=false] Whether choice is disabled\n   * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group\n   * @param {Object} [customProperties] Object containing user defined properties\n   * @return\n   * @private\n   */\n  _addChoice(\n    value,\n    label = null,\n    isSelected = false,\n    isDisabled = false,\n    groupId = -1,\n    customProperties = null,\n    placeholder = false,\n    keyCode = null,\n  ) {\n    if (typeof value === 'undefined' || value === null) {\n      return;\n    }\n\n    // Generate unique id\n    const choices = this.store.getChoices();\n    const choiceLabel = label || value;\n    const choiceId = choices ? choices.length + 1 : 1;\n    const choiceElementId = `${this.baseId}-${this.idNames.itemChoice}-${choiceId}`;\n\n    this.store.dispatch(\n      addChoice(\n        value,\n        choiceLabel,\n        choiceId,\n        groupId,\n        isDisabled,\n        choiceElementId,\n        customProperties,\n        placeholder,\n        keyCode,\n      ),\n    );\n\n    if (isSelected) {\n      this._addItem(\n        value,\n        choiceLabel,\n        choiceId,\n        undefined,\n        customProperties,\n        placeholder,\n        keyCode,\n      );\n    }\n  }\n\n  /**\n   * Clear all choices added to the store.\n   * @return\n   * @private\n   */\n  _clearChoices() {\n    this.store.dispatch(\n      clearChoices(),\n    );\n  }\n\n  /**\n   * Add group to dropdown\n   * @param {Object} group Group to add\n   * @param {Number} id Group ID\n   * @param {String} [valueKey] name of the value property on the object\n   * @param {String} [labelKey] name of the label property on the object\n   * @return\n   * @private\n   */\n  _addGroup(group, id, valueKey = 'value', labelKey = 'label') {\n    const groupChoices = isType('Object', group) ?\n      group.choices :\n      Array.from(group.getElementsByTagName('OPTION'));\n    const groupId = id || Math.floor(new Date().valueOf() * Math.random());\n    const isDisabled = group.disabled ? group.disabled : false;\n\n    if (groupChoices) {\n      this.store.dispatch(\n        addGroup(\n          group.label,\n          groupId,\n          true,\n          isDisabled,\n        ),\n      );\n\n      groupChoices.forEach((option) => {\n        const isOptDisabled = option.disabled || (option.parentNode && option.parentNode.disabled);\n        this._addChoice(\n          option[valueKey],\n          (isType('Object', option)) ? option[labelKey] : option.innerHTML,\n          option.selected,\n          isOptDisabled,\n          groupId,\n          option.customProperties,\n          option.placeholder,\n        );\n      });\n    } else {\n      this.store.dispatch(\n        addGroup(\n          group.label,\n          group.id,\n          false,\n          group.disabled,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Get template from name\n   * @param  {String}    template Name of template to get\n   * @param  {...}       args     Data to pass to template\n   * @return {HTMLElement}        Template\n   * @private\n   */\n  _getTemplate(template, ...args) {\n    if (!template) {\n      return null;\n    }\n    const templates = this.config.templates;\n    return templates[template](...args);\n  }\n\n  /**\n   * Create HTML element based on type and arguments\n   * @return\n   * @private\n   */\n  _createTemplates() {\n    const globalClasses = this.config.classNames;\n    const templates = {\n      containerOuter: (direction) => {\n        const tabIndex = this.isSelectOneElement ? 'tabindex=\"0\"' : '';\n        let role = this.isSelectElement ? 'role=\"listbox\"' : '';\n        let ariaAutoComplete = '';\n\n        if (this.isSelectElement && this.config.searchEnabled) {\n          role = 'role=\"combobox\"';\n          ariaAutoComplete = 'aria-autocomplete=\"list\"';\n        }\n\n        return strToEl(`\n          <div\n            class=\"${globalClasses.containerOuter}\"\n            data-type=\"${this.passedElement.type}\"\n            ${role}\n            ${tabIndex}\n            ${ariaAutoComplete}\n            aria-haspopup=\"true\"\n            aria-expanded=\"false\"\n            dir=\"${direction}\"\n            >\n          </div>\n        `);\n      },\n      containerInner: () => strToEl(`\n        <div class=\"${globalClasses.containerInner}\"></div>\n      `),\n      itemList: () => {\n        const localClasses = classNames(\n          globalClasses.list, {\n            [globalClasses.listSingle]: (this.isSelectOneElement),\n            [globalClasses.listItems]: (!this.isSelectOneElement),\n          },\n        );\n\n        return strToEl(`\n          <div class=\"${localClasses}\"></div>\n        `);\n      },\n      placeholder: value => strToEl(`\n        <div class=\"${globalClasses.placeholder}\">\n          ${value}\n        </div>\n      `),\n      item: (data) => {\n        const ariaSelected = data.active ? 'aria-selected=\"true\"' : '';\n        const ariaDisabled = data.disabled ? 'aria-disabled=\"true\"' : '';\n\n        let localClasses = classNames(\n          globalClasses.item, {\n            [globalClasses.highlightedState]: data.highlighted,\n            [globalClasses.itemSelectable]: !data.highlighted,\n            [globalClasses.placeholder]: data.placeholder,\n          },\n        );\n\n        if (this.config.removeItemButton) {\n          localClasses = classNames(\n            globalClasses.item, {\n              [globalClasses.highlightedState]: data.highlighted,\n              [globalClasses.itemSelectable]: !data.disabled,\n              [globalClasses.placeholder]: data.placeholder,\n            },\n          );\n\n          return strToEl(`\n            <div\n              class=\"${localClasses}\"\n              data-item\n              data-id=\"${data.id}\"\n              data-value=\"${data.value}\"\n              data-deletable\n              ${ariaSelected}\n              ${ariaDisabled}\n              >\n              ${data.label}<!--\n           --><button\n                type=\"button\"\n                class=\"${globalClasses.button}\"\n                data-button\n                aria-label=\"Remove item: '${data.value}'\"\n                >\n                Remove item\n              </button>\n            </div>\n          `);\n        }\n\n        return strToEl(`\n          <div\n            class=\"${localClasses}\"\n            data-item\n            data-id=\"${data.id}\"\n            data-value=\"${data.value}\"\n            ${ariaSelected}\n            ${ariaDisabled}\n            >\n            ${data.label}\n          </div>\n        `);\n      },\n      choiceList: () => {\n        const ariaMultiSelectable = !this.isSelectOneElement ?\n          'aria-multiselectable=\"true\"' :\n          '';\n\n        return strToEl(`\n          <div\n            class=\"${globalClasses.list}\"\n            dir=\"ltr\"\n            role=\"listbox\"\n            ${ariaMultiSelectable}\n            >\n          </div>\n        `);\n      },\n      choiceGroup: (data) => {\n        const ariaDisabled = data.disabled ? 'aria-disabled=\"true\"' : '';\n        const localClasses = classNames(\n          globalClasses.group, {\n            [globalClasses.itemDisabled]: data.disabled,\n          },\n        );\n\n        return strToEl(`\n          <div\n            class=\"${localClasses}\"\n            data-group\n            data-id=\"${data.id}\"\n            data-value=\"${data.value}\"\n            role=\"group\"\n            ${ariaDisabled}\n            >\n            <div class=\"${globalClasses.groupHeading}\">${data.value}</div>\n          </div>\n        `);\n      },\n      choice: (data) => {\n        const role = data.groupId > 0 ? 'role=\"treeitem\"' : 'role=\"option\"';\n        const localClasses = classNames(\n          globalClasses.item,\n          globalClasses.itemChoice, {\n            [globalClasses.itemDisabled]: data.disabled,\n            [globalClasses.itemSelectable]: !data.disabled,\n            [globalClasses.placeholder]: data.placeholder,\n          },\n        );\n\n        return strToEl(`\n          <div\n            class=\"${localClasses}\"\n            data-select-text=\"${this.config.itemSelectText}\"\n            data-choice\n            data-id=\"${data.id}\"\n            data-value=\"${data.value}\"\n            ${data.disabled ?\n              'data-choice-disabled aria-disabled=\"true\"' :\n              'data-choice-selectable'\n            }\n            id=\"${data.elementId}\"\n            ${role}\n            >\n            ${data.label}\n          </div>\n        `);\n      },\n      input: () => {\n        const localClasses = classNames(\n          globalClasses.input,\n          globalClasses.inputCloned,\n        );\n\n        return strToEl(`\n          <input\n            type=\"text\"\n            class=\"${localClasses}\"\n            autocomplete=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            role=\"textbox\"\n            aria-autocomplete=\"list\"\n            >\n        `);\n      },\n      dropdown: () => {\n        const localClasses = classNames(\n          globalClasses.list,\n          globalClasses.listDropdown,\n        );\n\n        return strToEl(`\n          <div\n            class=\"${localClasses}\"\n            aria-expanded=\"false\"\n            >\n          </div>\n        `);\n      },\n      notice: (label, type = '') => {\n        const localClasses = classNames(\n          globalClasses.item,\n          globalClasses.itemChoice, {\n            [globalClasses.noResults]: (type === 'no-results'),\n            [globalClasses.noChoices]: (type === 'no-choices'),\n          },\n        );\n\n        return strToEl(`\n          <div class=\"${localClasses}\">\n            ${label}\n          </div>\n        `);\n      },\n      option: data => strToEl(`\n        <option value=\"${data.value}\" selected>${data.label}</option>\n      `),\n    };\n\n    // User's custom templates\n    const callbackTemplate = this.config.callbackOnCreateTemplates;\n    let userTemplates = {};\n    if (callbackTemplate && isType('Function', callbackTemplate)) {\n      userTemplates = callbackTemplate.call(this, strToEl);\n    }\n\n    this.config.templates = extend(templates, userTemplates);\n  }\n\n  /**\n   * Create DOM structure around passed select element\n   * @return\n   * @private\n   */\n  _createInput() {\n    const direction = this.passedElement.getAttribute('dir') || 'ltr';\n    const containerOuter = this._getTemplate('containerOuter', direction);\n    const containerInner = this._getTemplate('containerInner');\n    const itemList = this._getTemplate('itemList');\n    const choiceList = this._getTemplate('choiceList');\n    const input = this._getTemplate('input');\n    const dropdown = this._getTemplate('dropdown');\n\n    this.containerOuter = new Container(this, containerOuter);\n    this.containerInner = new Container(this, containerInner);\n    this.input = new Input(this, input);\n    this.choiceList = new List(this, choiceList);\n    this.itemList = new List(this, itemList);\n    this.dropdown = new Dropdown(this, dropdown, this.config.classNames);\n\n    // Hide passed input\n    this.passedElement.classList.add(\n      this.config.classNames.input,\n      this.config.classNames.hiddenState,\n    );\n\n    // Remove element from tab index\n    this.passedElement.tabIndex = '-1';\n\n    // Backup original styles if any\n    const origStyle = this.passedElement.getAttribute('style');\n\n    if (origStyle) {\n      this.passedElement.setAttribute('data-choice-orig-style', origStyle);\n    }\n\n    this.passedElement.setAttribute('style', 'display:none;');\n    this.passedElement.setAttribute('aria-hidden', 'true');\n    this.passedElement.setAttribute('data-choice', 'active');\n\n    // Wrap input in container preserving DOM ordering\n    wrap(this.passedElement, this.containerInner.element);\n\n    // Wrapper inner container with outer container\n    wrap(this.containerInner.element, this.containerOuter.element);\n\n    if (this.isSelectOneElement) {\n      this.input.setPlaceholder(this.config.searchPlaceholderValue || '');\n    } else if (this.placeholder) {\n      this.input.setPlaceholder(this.placeholder);\n      this.input.setWidth(true);\n    }\n\n    if (!this.config.addItems) {\n      this.disable();\n    }\n\n    this.containerOuter.element.appendChild(this.containerInner.element);\n    this.containerOuter.element.appendChild(this.dropdown.element);\n    this.containerInner.element.appendChild(itemList);\n\n    if (!this.isTextElement) {\n      dropdown.appendChild(choiceList);\n    }\n\n    if (this.isSelectMultipleElement || this.isTextElement) {\n      this.containerInner.element.appendChild(this.input.element);\n    } else if (this.canSearch) {\n      dropdown.insertBefore(input, dropdown.firstChild);\n    }\n\n    if (this.isSelectElement) {\n      const passedGroups = Array.from(this.passedElement.getElementsByTagName('OPTGROUP'));\n\n      this.highlightPosition = 0;\n      this.isSearching = false;\n\n      if (passedGroups && passedGroups.length) {\n        passedGroups.forEach((group) => {\n          this._addGroup(group, (group.id || null));\n        });\n      } else {\n        const passedOptions = Array.from(this.passedElement.options);\n        const filter = this.config.sortFilter;\n        const allChoices = this.presetChoices;\n\n        // Create array of options from option elements\n        passedOptions.forEach((o) => {\n          allChoices.push({\n            value: o.value,\n            label: o.innerHTML,\n            selected: o.selected,\n            disabled: o.disabled || o.parentNode.disabled,\n            placeholder: o.hasAttribute('placeholder'),\n          });\n        });\n\n        // If sorting is enabled or the user is searching, filter choices\n        if (this.config.shouldSort) {\n          allChoices.sort(filter);\n        }\n\n        // Determine whether there is a selected choice\n        const hasSelectedChoice = allChoices.some(choice => choice.selected);\n\n        // Add each choice\n        allChoices.forEach((choice, index) => {\n          // Pre-select first choice if it's a single select\n          if (this.isSelectOneElement) {\n            // If there is a selected choice already or the choice is not\n            // the first in the array, add each choice normally\n            // Otherwise pre-select the first choice in the array\n            const shouldPreselect = (!hasSelectedChoice || (hasSelectedChoice && index === 0));\n            const isSelected = shouldPreselect ? true : choice.selected;\n            const isDisabled = shouldPreselect ? false : choice.disabled;\n\n            this._addChoice(\n              choice.value,\n              choice.label,\n              isSelected,\n              isDisabled,\n              undefined,\n              choice.customProperties,\n              choice.placeholder,\n            );\n          } else {\n            this._addChoice(\n              choice.value,\n              choice.label,\n              choice.selected,\n              choice.disabled,\n              undefined,\n              choice.customProperties,\n              choice.placeholder,\n            );\n          }\n        });\n      }\n    } else if (this.isTextElement) {\n      // Add any preset values seperated by delimiter\n      this.presetItems.forEach((item) => {\n        const itemType = getType(item);\n        if (itemType === 'Object') {\n          if (!item.value) {\n            return;\n          }\n          this._addItem(\n            item.value,\n            item.label,\n            item.id,\n            undefined,\n            item.customProperties,\n            item.placeholder,\n          );\n        } else if (itemType === 'String') {\n          this._addItem(item);\n        }\n      });\n    }\n  }\n\n  /* =====  End of Private functions  ====== */\n}\n\nChoices.userDefaults = {};\n\nmodule.exports = Choices;\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/choices.js","/**\n * @license\n * Fuse - Lightweight fuzzy-search\n *\n * Copyright (c) 2012-2016 Kirollos Risk <kirollos@gmail.com>.\n * All Rights Reserved. Apache Software License 2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n;(function (global) {\n  'use strict'\n\n  /** @type {function(...*)} */\n  function log () {\n    console.log.apply(console, arguments)\n  }\n\n  var defaultOptions = {\n    // The name of the identifier property. If specified, the returned result will be a list\n    // of the items' dentifiers, otherwise it will be a list of the items.\n    id: null,\n\n    // Indicates whether comparisons should be case sensitive.\n\n    caseSensitive: false,\n\n    // An array of values that should be included from the searcher's output. When this array\n    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.\n    // Values you can include are `score`, `matchedLocations`\n    include: [],\n\n    // Whether to sort the result list, by score\n    shouldSort: true,\n\n    // The search function to use\n    // Note that the default search function ([[Function]]) must conform to the following API:\n    //\n    //  @param pattern The pattern string to search\n    //  @param options The search option\n    //  [[Function]].constructor = function(pattern, options)\n    //\n    //  @param text: the string to search in for the pattern\n    //  @return Object in the form of:\n    //    - isMatch: boolean\n    //    - score: Int\n    //  [[Function]].prototype.search = function(text)\n    searchFn: BitapSearcher,\n\n    // Default sort function\n    sortFn: function (a, b) {\n      return a.score - b.score\n    },\n\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: deepValue,\n\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n\n    // Will print to the console. Useful for debugging.\n    verbose: false,\n\n    // When true, the search algorithm will search individual words **and** the full string,\n    // computing the final score as a function of both. Note that when `tokenize` is `true`,\n    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.\n    tokenize: false,\n\n    // When true, the result set will only include records that match all tokens. Will only work\n    // if `tokenize` is also true.\n    matchAllTokens: false,\n\n    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.\n    tokenSeparator: / +/g,\n\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1,\n\n    // When true, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    findAllMatches: false\n  }\n\n  /**\n   * @constructor\n   * @param {!Array} list\n   * @param {!Object<string, *>} options\n   */\n  function Fuse (list, options) {\n    var key\n\n    this.list = list\n    this.options = options = options || {}\n\n    for (key in defaultOptions) {\n      if (!defaultOptions.hasOwnProperty(key)) {\n        continue;\n      }\n      // Add boolean type options\n      if (typeof defaultOptions[key] === 'boolean') {\n        this.options[key] = key in options ? options[key] : defaultOptions[key];\n      // Add all other options\n      } else {\n        this.options[key] = options[key] || defaultOptions[key]\n      }\n    }\n  }\n\n  Fuse.VERSION = '2.7.3'\n\n  /**\n   * Sets a new list for Fuse to match against.\n   * @param {!Array} list\n   * @return {!Array} The newly set list\n   * @public\n   */\n  Fuse.prototype.set = function (list) {\n    this.list = list\n    return list\n  }\n\n  Fuse.prototype.search = function (pattern) {\n    if (this.options.verbose) log('\\nSearch term:', pattern, '\\n')\n\n    this.pattern = pattern\n    this.results = []\n    this.resultMap = {}\n    this._keyMap = null\n\n    this._prepareSearchers()\n    this._startSearch()\n    this._computeScore()\n    this._sort()\n\n    var output = this._format()\n    return output\n  }\n\n  Fuse.prototype._prepareSearchers = function () {\n    var options = this.options\n    var pattern = this.pattern\n    var searchFn = options.searchFn\n    var tokens = pattern.split(options.tokenSeparator)\n    var i = 0\n    var len = tokens.length\n\n    if (this.options.tokenize) {\n      this.tokenSearchers = []\n      for (; i < len; i++) {\n        this.tokenSearchers.push(new searchFn(tokens[i], options))\n      }\n    }\n    this.fullSeacher = new searchFn(pattern, options)\n  }\n\n  Fuse.prototype._startSearch = function () {\n    var options = this.options\n    var getFn = options.getFn\n    var list = this.list\n    var listLen = list.length\n    var keys = this.options.keys\n    var keysLen = keys.length\n    var key\n    var weight\n    var item = null\n    var i\n    var j\n\n    // Check the first item in the list, if it's a string, then we assume\n    // that every item in the list is also a string, and thus it's a flattened array.\n    if (typeof list[0] === 'string') {\n      // Iterate over every item\n      for (i = 0; i < listLen; i++) {\n        this._analyze('', list[i], i, i)\n      }\n    } else {\n      this._keyMap = {}\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      // Iterate over every item\n      for (i = 0; i < listLen; i++) {\n        item = list[i]\n        // Iterate over every key\n        for (j = 0; j < keysLen; j++) {\n          key = keys[j]\n          if (typeof key !== 'string') {\n            weight = (1 - key.weight) || 1\n            this._keyMap[key.name] = {\n              weight: weight\n            }\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1')\n            }\n            key = key.name\n          } else {\n            this._keyMap[key] = {\n              weight: 1\n            }\n          }\n          this._analyze(key, getFn(item, key, []), item, i)\n        }\n      }\n    }\n  }\n\n  Fuse.prototype._analyze = function (key, text, entity, index) {\n    var options = this.options\n    var words\n    var scores\n    var exists = false\n    var existingResult\n    var averageScore\n    var finalScore\n    var scoresLen\n    var mainSearchResult\n    var tokenSearcher\n    var termScores\n    var word\n    var tokenSearchResult\n    var hasMatchInText\n    var checkTextMatches\n    var i\n    var j\n\n    // Check if the text can be searched\n    if (text === undefined || text === null) {\n      return\n    }\n\n    scores = []\n\n    var numTextMatches = 0\n\n    if (typeof text === 'string') {\n      words = text.split(options.tokenSeparator)\n\n      if (options.verbose) log('---------\\nKey:', key)\n\n      if (this.options.tokenize) {\n        for (i = 0; i < this.tokenSearchers.length; i++) {\n          tokenSearcher = this.tokenSearchers[i]\n\n          if (options.verbose) log('Pattern:', tokenSearcher.pattern)\n\n          termScores = []\n          hasMatchInText = false\n\n          for (j = 0; j < words.length; j++) {\n            word = words[j]\n            tokenSearchResult = tokenSearcher.search(word)\n            var obj = {}\n            if (tokenSearchResult.isMatch) {\n              obj[word] = tokenSearchResult.score\n              exists = true\n              hasMatchInText = true\n              scores.push(tokenSearchResult.score)\n            } else {\n              obj[word] = 1\n              if (!this.options.matchAllTokens) {\n                scores.push(1)\n              }\n            }\n            termScores.push(obj)\n          }\n\n          if (hasMatchInText) {\n            numTextMatches++\n          }\n\n          if (options.verbose) log('Token scores:', termScores)\n        }\n\n        averageScore = scores[0]\n        scoresLen = scores.length\n        for (i = 1; i < scoresLen; i++) {\n          averageScore += scores[i]\n        }\n        averageScore = averageScore / scoresLen\n\n        if (options.verbose) log('Token score average:', averageScore)\n      }\n\n      mainSearchResult = this.fullSeacher.search(text)\n      if (options.verbose) log('Full text score:', mainSearchResult.score)\n\n      finalScore = mainSearchResult.score\n      if (averageScore !== undefined) {\n        finalScore = (finalScore + averageScore) / 2\n      }\n\n      if (options.verbose) log('Score average:', finalScore)\n\n      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true\n\n      if (options.verbose) log('Check Matches', checkTextMatches)\n\n      // If a match is found, add the item to <rawResults>, including its score\n      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n        // Check if the item already exists in our results\n        existingResult = this.resultMap[index]\n\n        if (existingResult) {\n          // Use the lowest score\n          // existingResult.score, bitapResult.score\n          existingResult.output.push({\n            key: key,\n            score: finalScore,\n            matchedIndices: mainSearchResult.matchedIndices\n          })\n        } else {\n          // Add it to the raw result list\n          this.resultMap[index] = {\n            item: entity,\n            output: [{\n              key: key,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            }]\n          }\n\n          this.results.push(this.resultMap[index])\n        }\n      }\n    } else if (isArray(text)) {\n      for (i = 0; i < text.length; i++) {\n        this._analyze(key, text[i], entity, index)\n      }\n    }\n  }\n\n  Fuse.prototype._computeScore = function () {\n    var i\n    var j\n    var keyMap = this._keyMap\n    var totalScore\n    var output\n    var scoreLen\n    var score\n    var weight\n    var results = this.results\n    var bestScore\n    var nScore\n\n    if (this.options.verbose) log('\\n\\nComputing score:\\n')\n\n    for (i = 0; i < results.length; i++) {\n      totalScore = 0\n      output = results[i].output\n      scoreLen = output.length\n\n      bestScore = 1\n\n      for (j = 0; j < scoreLen; j++) {\n        score = output[j].score\n        weight = keyMap ? keyMap[output[j].key].weight : 1\n\n        nScore = score * weight\n\n        if (weight !== 1) {\n          bestScore = Math.min(bestScore, nScore)\n        } else {\n          totalScore += nScore\n          output[j].nScore = nScore\n        }\n      }\n\n      if (bestScore === 1) {\n        results[i].score = totalScore / scoreLen\n      } else {\n        results[i].score = bestScore\n      }\n\n      if (this.options.verbose) log(results[i])\n    }\n  }\n\n  Fuse.prototype._sort = function () {\n    var options = this.options\n    if (options.shouldSort) {\n      if (options.verbose) log('\\n\\nSorting....')\n      this.results.sort(options.sortFn)\n    }\n  }\n\n  Fuse.prototype._format = function () {\n    var options = this.options\n    var getFn = options.getFn\n    var finalOutput = []\n    var i\n    var len\n    var results = this.results\n    var replaceValue\n    var getItemAtIndex\n    var include = options.include\n\n    if (options.verbose) log('\\n\\nOutput:\\n\\n', results)\n\n    // Helper function, here for speed-up, which replaces the item with its value,\n    // if the options specifies it,\n    replaceValue = options.id ? function (index) {\n      results[index].item = getFn(results[index].item, options.id, [])[0]\n    } : function () {}\n\n    getItemAtIndex = function (index) {\n      var record = results[index]\n      var data\n      var j\n      var output\n      var _item\n      var _result\n\n      // If `include` has values, put the item in the result\n      if (include.length > 0) {\n        data = {\n          item: record.item\n        }\n        if (include.indexOf('matches') !== -1) {\n          output = record.output\n          data.matches = []\n          for (j = 0; j < output.length; j++) {\n            _item = output[j]\n            _result = {\n              indices: _item.matchedIndices\n            }\n            if (_item.key) {\n              _result.key = _item.key\n            }\n            data.matches.push(_result)\n          }\n        }\n\n        if (include.indexOf('score') !== -1) {\n          data.score = results[index].score\n        }\n\n      } else {\n        data = record.item\n      }\n\n      return data\n    }\n\n    // From the results, push into a new array only the item identifier (if specified)\n    // of the entire item.  This is because we don't want to return the <results>,\n    // since it contains other metadata\n    for (i = 0, len = results.length; i < len; i++) {\n      replaceValue(i)\n      finalOutput.push(getItemAtIndex(i))\n    }\n\n    return finalOutput\n  }\n\n  // Helpers\n\n  function deepValue (obj, path, list) {\n    var firstSegment\n    var remaining\n    var dotIndex\n    var value\n    var i\n    var len\n\n    if (!path) {\n      // If there's no path left, we've gotten to the object we care about.\n      list.push(obj)\n    } else {\n      dotIndex = path.indexOf('.')\n\n      if (dotIndex !== -1) {\n        firstSegment = path.slice(0, dotIndex)\n        remaining = path.slice(dotIndex + 1)\n      } else {\n        firstSegment = path\n      }\n\n      value = obj[firstSegment]\n      if (value !== null && value !== undefined) {\n        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n          list.push(value)\n        } else if (isArray(value)) {\n          // Search each item in the array.\n          for (i = 0, len = value.length; i < len; i++) {\n            deepValue(value[i], remaining, list)\n          }\n        } else if (remaining) {\n          // An object. Recurse further.\n          deepValue(value, remaining, list)\n        }\n      }\n    }\n\n    return list\n  }\n\n  function isArray (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]'\n  }\n\n  /**\n   * Adapted from \"Diff, Match and Patch\", by Google\n   *\n   *   http://code.google.com/p/google-diff-match-patch/\n   *\n   * Modified by: Kirollos Risk <kirollos@gmail.com>\n   * -----------------------------------------------\n   * Details: the algorithm and structure was modified to allow the creation of\n   * <Searcher> instances with a <search> method which does the actual\n   * bitap search. The <pattern> (the string that is searched for) is only defined\n   * once per instance and thus it eliminates redundant re-creation when searching\n   * over a list of strings.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\")\n   * you may not use this file except in compliance with the License.\n   *\n   * @constructor\n   */\n  function BitapSearcher (pattern, options) {\n    options = options || {}\n    this.options = options\n    this.options.location = options.location || BitapSearcher.defaultOptions.location\n    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance\n    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold\n    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength\n\n    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase()\n    this.patternLen = pattern.length\n\n    if (this.patternLen <= this.options.maxPatternLength) {\n      this.matchmask = 1 << (this.patternLen - 1)\n      this.patternAlphabet = this._calculatePatternAlphabet()\n    }\n  }\n\n  BitapSearcher.defaultOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100,\n\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n\n    // Machine word size\n    maxPatternLength: 32\n  }\n\n  /**\n   * Initialize the alphabet for the Bitap algorithm.\n   * @return {Object} Hash of character locations.\n   * @private\n   */\n  BitapSearcher.prototype._calculatePatternAlphabet = function () {\n    var mask = {},\n      i = 0\n\n    for (i = 0; i < this.patternLen; i++) {\n      mask[this.pattern.charAt(i)] = 0\n    }\n\n    for (i = 0; i < this.patternLen; i++) {\n      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1)\n    }\n\n    return mask\n  }\n\n  /**\n   * Compute and return the score for a match with `e` errors and `x` location.\n   * @param {number} errors Number of errors in match.\n   * @param {number} location Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  BitapSearcher.prototype._bitapScore = function (errors, location) {\n    var accuracy = errors / this.patternLen,\n      proximity = Math.abs(this.options.location - location)\n\n    if (!this.options.distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy\n    }\n    return accuracy + (proximity / this.options.distance)\n  }\n\n  /**\n   * Compute and return the result of the search\n   * @param {string} text The text to search in\n   * @return {{isMatch: boolean, score: number}} Literal containing:\n   *                          isMatch - Whether the text is a match or not\n   *                          score - Overall score for the match\n   * @public\n   */\n  BitapSearcher.prototype.search = function (text) {\n    var options = this.options\n    var i\n    var j\n    var textLen\n    var findAllMatches\n    var location\n    var threshold\n    var bestLoc\n    var binMin\n    var binMid\n    var binMax\n    var start, finish\n    var bitArr\n    var lastBitArr\n    var charMatch\n    var score\n    var locations\n    var matches\n    var isMatched\n    var matchMask\n    var matchedIndices\n    var matchesLen\n    var match\n\n    text = options.caseSensitive ? text : text.toLowerCase()\n\n    if (this.pattern === text) {\n      // Exact match\n      return {\n        isMatch: true,\n        score: 0,\n        matchedIndices: [[0, text.length - 1]]\n      }\n    }\n\n    // When pattern length is greater than the machine word length, just do a a regex comparison\n    if (this.patternLen > options.maxPatternLength) {\n      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')))\n      isMatched = !!matches\n\n      if (isMatched) {\n        matchedIndices = []\n        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {\n          match = matches[i]\n          matchedIndices.push([text.indexOf(match), match.length - 1])\n        }\n      }\n\n      return {\n        isMatch: isMatched,\n        // TODO: revisit this score\n        score: isMatched ? 0.5 : 1,\n        matchedIndices: matchedIndices\n      }\n    }\n\n    findAllMatches = options.findAllMatches\n\n    location = options.location\n    // Set starting location at beginning text and initialize the alphabet.\n    textLen = text.length\n    // Highest score beyond which we give up.\n    threshold = options.threshold\n    // Is there a nearby exact match? (speedup)\n    bestLoc = text.indexOf(this.pattern, location)\n\n    // a mask of the matches\n    matchMask = []\n    for (i = 0; i < textLen; i++) {\n      matchMask[i] = 0\n    }\n\n    if (bestLoc != -1) {\n      threshold = Math.min(this._bitapScore(0, bestLoc), threshold)\n      // What about in the other direction? (speed up)\n      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen)\n\n      if (bestLoc != -1) {\n        threshold = Math.min(this._bitapScore(0, bestLoc), threshold)\n      }\n    }\n\n    bestLoc = -1\n    score = 1\n    locations = []\n    binMax = this.patternLen + textLen\n\n    for (i = 0; i < this.patternLen; i++) {\n      // Scan for the best match; each iteration allows for one more error.\n      // Run a binary search to determine how far from the match location we can stray\n      // at this error level.\n      binMin = 0\n      binMid = binMax\n      while (binMin < binMid) {\n        if (this._bitapScore(i, location + binMid) <= threshold) {\n          binMin = binMid\n        } else {\n          binMax = binMid\n        }\n        binMid = Math.floor((binMax - binMin) / 2 + binMin)\n      }\n\n      // Use the result from this iteration as the maximum for the next.\n      binMax = binMid\n      start = Math.max(1, location - binMid + 1)\n      if (findAllMatches) {\n        finish = textLen;\n      } else {\n        finish = Math.min(location + binMid, textLen) + this.patternLen\n      }\n\n      // Initialize the bit array\n      bitArr = Array(finish + 2)\n\n      bitArr[finish + 1] = (1 << i) - 1\n\n      for (j = finish; j >= start; j--) {\n        charMatch = this.patternAlphabet[text.charAt(j - 1)]\n\n        if (charMatch) {\n          matchMask[j - 1] = 1\n        }\n\n        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch\n\n        if (i !== 0) {\n          // Subsequent passes: fuzzy match.\n          bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]\n        }\n        if (bitArr[j] & this.matchmask) {\n          score = this._bitapScore(i, j - 1)\n\n          // This match will almost certainly be better than any existing match.\n          // But check anyway.\n          if (score <= threshold) {\n            // Indeed it is\n            threshold = score\n            bestLoc = j - 1\n            locations.push(bestLoc)\n\n            // Already passed loc, downhill from here on in.\n            if (bestLoc <= location) {\n              break\n            }\n\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * location - bestLoc)\n          }\n        }\n      }\n\n      // No hope for a (better) match at greater error levels.\n      if (this._bitapScore(i + 1, location) > threshold) {\n        break\n      }\n      lastBitArr = bitArr\n    }\n\n    matchedIndices = this._getMatchedIndices(matchMask)\n\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    return {\n      isMatch: bestLoc >= 0,\n      score: score === 0 ? 0.001 : score,\n      matchedIndices: matchedIndices\n    }\n  }\n\n  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {\n    var matchedIndices = []\n    var start = -1\n    var end = -1\n    var i = 0\n    var match\n    var len = matchMask.length\n    for (; i < len; i++) {\n      match = matchMask[i]\n      if (match && start === -1) {\n        start = i\n      } else if (!match && start !== -1) {\n        end = i - 1\n        if ((end - start) + 1 >= this.options.minMatchCharLength) {\n            matchedIndices.push([start, end])\n        }\n        start = -1\n      }\n    }\n    if (matchMask[i - 1]) {\n      if ((i-1 - start) + 1 >= this.options.minMatchCharLength) {\n        matchedIndices.push([start, i - 1])\n      }\n    }\n    return matchedIndices\n  }\n\n  // Export to Common JS Loader\n  if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Fuse\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return Fuse\n    })\n  } else {\n    // Browser globals (root is window)\n    global.Fuse = Fuse\n  }\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fuse.js/src/fuse.js\n// module id = 2\n// module chunks = 0","/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tclasses.push(classNames.apply(null, arg));\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/classnames/index.js\n// module id = 3\n// module chunks = 0","import { createStore } from 'redux';\r\nimport rootReducer from './../reducers/index';\r\n\r\nexport default class Store {\r\n  constructor() {\r\n    this.store = createStore(\r\n      rootReducer,\r\n      window.devToolsExtension ?\r\n        window.devToolsExtension() :\r\n        undefined,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get store object (wrapping Redux method)\r\n   * @return {Object} State\r\n   */\r\n  getState() {\r\n    return this.store.getState();\r\n  }\r\n\r\n  /**\r\n   * Dispatch event to store (wrapped Redux method)\r\n   * @param  {Function} action Action function to trigger\r\n   * @return\r\n   */\r\n  dispatch(action) {\r\n    this.store.dispatch(action);\r\n  }\r\n\r\n  /**\r\n   * Subscribe store to function call (wrapped Redux method)\r\n   * @param  {Function} onChange Function to trigger when state changes\r\n   * @return\r\n   */\r\n  subscribe(onChange) {\r\n    this.store.subscribe(onChange);\r\n  }\r\n\r\n  /**\r\n   * Get items from store\r\n   * @return {Array} Item objects\r\n   */\r\n  getItems() {\r\n    const state = this.store.getState();\r\n    return state.items;\r\n  }\r\n\r\n  /**\r\n   * Get active items from store\r\n   * @return {Array} Item objects\r\n   */\r\n  getItemsFilteredByActive() {\r\n    const items = this.getItems();\r\n    const values = items.filter(item => item.active === true, []);\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Get items from store reduced to just their values\r\n   * @return {Array} Item objects\r\n   */\r\n  getItemsReducedToValues(items = this.getItems()) {\r\n    const values = items.reduce((prev, current) => {\r\n      prev.push(current.value);\r\n      return prev;\r\n    }, []);\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Get choices from store\r\n   * @return {Array} Option objects\r\n   */\r\n  getChoices() {\r\n    const state = this.store.getState();\r\n    return state.choices;\r\n  }\r\n\r\n  /**\r\n   * Get active choices from store\r\n   * @return {Array} Option objects\r\n   */\r\n  getChoicesFilteredByActive() {\r\n    const choices = this.getChoices();\r\n    const values = choices.filter(choice => choice.active === true);\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Get selectable choices from store\r\n   * @return {Array} Option objects\r\n   */\r\n  getChoicesFilteredBySelectable() {\r\n    const choices = this.getChoices();\r\n    const values = choices.filter(choice => choice.disabled !== true);\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Get choices that can be searched (excluding placeholders)\r\n   * @return {Array} Option objects\r\n   */\r\n  getSearchableChoices() {\r\n    const filtered = this.getChoicesFilteredBySelectable();\r\n    return filtered.filter(choice => choice.placeholder !== true);\r\n  }\r\n\r\n  /**\r\n   * Get single choice by it's ID\r\n   * @return {Object} Found choice\r\n   */\r\n  getChoiceById(id) {\r\n    if (id) {\r\n      const choices = this.getChoicesFilteredByActive();\r\n      const foundChoice = choices.find(choice => choice.id === parseInt(id, 10));\r\n      return foundChoice;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get groups from store\r\n   * @return {Array} Group objects\r\n   */\r\n  getGroups() {\r\n    const state = this.store.getState();\r\n    return state.groups;\r\n  }\r\n\r\n  /**\r\n   * Get active groups from store\r\n   * @return {Array} Group objects\r\n   */\r\n  getGroupsFilteredByActive() {\r\n    const groups = this.getGroups();\r\n    const choices = this.getChoices();\r\n\r\n    const values = groups.filter((group) => {\r\n      const isActive = group.active === true && group.disabled === false;\r\n      const hasActiveOptions = choices.some(choice =>\r\n        choice.active === true && choice.disabled === false,\r\n      );\r\n      return isActive && hasActiveOptions;\r\n    }, []);\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Get group by group id\r\n   * @param  {Number} id Group ID\r\n   * @return {Object}    Group data\r\n   */\r\n  getGroupById(id) {\r\n    const groups = this.getGroups();\r\n    const foundGroup = groups.find(group => group.id === id);\r\n\r\n    return foundGroup;\r\n  }\r\n\r\n  /**\r\n   * Get placeholder choice from store\r\n   * @return {Object} Found placeholder\r\n   */\r\n  getPlaceholderChoice() {\r\n    const choices = this.getChoices();\r\n    const placeholderChoice = [...choices]\r\n      .reverse()\r\n      .find(choice => choice.placeholder === true);\r\n\r\n    return placeholderChoice;\r\n  }\r\n}\r\n\r\nmodule.exports = Store;\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/store/store.js","'use strict';\n\nexports.__esModule = true;\nexports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;\n\nvar _createStore = require('./createStore');\n\nvar _createStore2 = _interopRequireDefault(_createStore);\n\nvar _combineReducers = require('./combineReducers');\n\nvar _combineReducers2 = _interopRequireDefault(_combineReducers);\n\nvar _bindActionCreators = require('./bindActionCreators');\n\nvar _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);\n\nvar _applyMiddleware = require('./applyMiddleware');\n\nvar _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexports.createStore = _createStore2['default'];\nexports.combineReducers = _combineReducers2['default'];\nexports.bindActionCreators = _bindActionCreators2['default'];\nexports.applyMiddleware = _applyMiddleware2['default'];\nexports.compose = _compose2['default'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/index.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports.ActionTypes = undefined;\nexports['default'] = createStore;\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = exports.ActionTypes = {\n  INIT: '@@redux/INIT'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};function createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!(0, _isPlainObject2['default'])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[_symbolObservable2['default']] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[_symbolObservable2['default']] = observable, _ref2;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/createStore.js\n// module id = 6\n// module chunks = 0","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isPlainObject.js\n// module id = 7\n// module chunks = 0","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseGetTag.js\n// module id = 8\n// module chunks = 0","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Symbol.js\n// module id = 9\n// module chunks = 0","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_root.js\n// module id = 10\n// module chunks = 0","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_freeGlobal.js\n// module id = 11\n// module chunks = 0","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getRawTag.js\n// module id = 12\n// module chunks = 0","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_objectToString.js\n// module id = 13\n// module chunks = 0","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getPrototype.js\n// module id = 14\n// module chunks = 0","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_overArg.js\n// module id = 15\n// module chunks = 0","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isObjectLike.js\n// module id = 16\n// module chunks = 0","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/index.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/index.js\n// module id = 18\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 19\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/symbol-observable/lib/ponyfill.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports['default'] = combineReducers;\n\nvar _createStore = require('./createStore');\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _warning = require('./utils/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!(0, _isPlainObject2['default'])(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        (0, _warning2['default'])('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        (0, _warning2['default'])(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/combineReducers.js\n// module id = 21\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports['default'] = warning;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/utils/warning.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports['default'] = bindActionCreators;\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/bindActionCreators.js\n// module id = 23\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = applyMiddleware;\n\nvar _compose = require('./compose');\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/applyMiddleware.js\n// module id = 24\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = compose;\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/redux/lib/compose.js\n// module id = 25\n// module chunks = 0","import { combineReducers } from 'redux';\r\nimport items from './items';\r\nimport groups from './groups';\r\nimport choices from './choices';\r\n\r\nconst appReducer = combineReducers({\r\n  items,\r\n  groups,\r\n  choices,\r\n});\r\n\r\nconst rootReducer = (passedState, action) => {\r\n  let state = passedState;\r\n  // If we are clearing all items, groups and options we reassign\r\n  // state and then pass that state to our proper reducer. This isn't\r\n  // mutating our actual state\r\n  // See: http://stackoverflow.com/a/35641992\r\n  if (action.type === 'CLEAR_ALL') {\r\n    state = undefined;\r\n  }\r\n\r\n  return appReducer(state, action);\r\n};\r\n\r\nexport default rootReducer;\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/reducers/index.js","const items = (state = [], action) => {\r\n  switch (action.type) {\r\n    case 'ADD_ITEM': {\r\n      // Add object to items array\r\n      const newState = [...state, {\r\n        id: action.id,\r\n        choiceId: action.choiceId,\r\n        groupId: action.groupId,\r\n        value: action.value,\r\n        label: action.label,\r\n        active: true,\r\n        highlighted: false,\r\n        customProperties: action.customProperties,\r\n        placeholder: (action.placeholder || false),\r\n        keyCode: null,\r\n      }];\r\n\r\n      return newState.map((obj) => {\r\n        const item = obj;\r\n        if (item.highlighted) {\r\n          item.highlighted = false;\r\n        }\r\n        return item;\r\n      });\r\n    }\r\n\r\n    case 'REMOVE_ITEM': {\r\n      // Set item to inactive\r\n      return state.map((obj) => {\r\n        const item = obj;\r\n        if (item.id === action.id) {\r\n          item.active = false;\r\n        }\r\n        return item;\r\n      });\r\n    }\r\n\r\n    case 'HIGHLIGHT_ITEM': {\r\n      return state.map((obj) => {\r\n        const item = obj;\r\n        if (item.id === action.id) {\r\n          item.highlighted = action.highlighted;\r\n        }\r\n        return item;\r\n      });\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\nexport default items;\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/reducers/items.js","const groups = (state = [], action) => {\r\n  switch (action.type) {\r\n    case 'ADD_GROUP': {\r\n      return [...state, {\r\n        id: action.id,\r\n        value: action.value,\r\n        active: action.active,\r\n        disabled: action.disabled,\r\n      }];\r\n    }\r\n\r\n    case 'CLEAR_CHOICES': {\r\n      return [];\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\nexport default groups;\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/reducers/groups.js","const choices = (state = [], action) => {\r\n  switch (action.type) {\r\n    case 'ADD_CHOICE': {\r\n      /*\r\n          A disabled choice appears in the choice dropdown but cannot be selected\r\n          A selected choice has been added to the passed input's value (added as an item)\r\n          An active choice appears within the choice dropdown\r\n       */\r\n      return [...state, {\r\n        id: action.id,\r\n        elementId: action.elementId,\r\n        groupId: action.groupId,\r\n        value: action.value,\r\n        label: (action.label || action.value),\r\n        disabled: (action.disabled || false),\r\n        selected: false,\r\n        active: true,\r\n        score: 9999,\r\n        customProperties: action.customProperties,\r\n        placeholder: (action.placeholder || false),\r\n        keyCode: null,\r\n      }];\r\n    }\r\n\r\n    case 'ADD_ITEM': {\r\n      let newState = state;\r\n\r\n      // If all choices need to be activated\r\n      if (action.activateOptions) {\r\n        newState = state.map((obj) => {\r\n          const choice = obj;\r\n          choice.active = action.active;\r\n          return choice;\r\n        });\r\n      }\r\n      // When an item is added and it has an associated choice,\r\n      // we want to disable it so it can't be chosen again\r\n      if (action.choiceId > -1) {\r\n        newState = state.map((obj) => {\r\n          const choice = obj;\r\n          if (choice.id === parseInt(action.choiceId, 10)) {\r\n            choice.selected = true;\r\n          }\r\n          return choice;\r\n        });\r\n      }\r\n\r\n      return newState;\r\n    }\r\n\r\n    case 'REMOVE_ITEM': {\r\n      // When an item is removed and it has an associated choice,\r\n      // we want to re-enable it so it can be chosen again\r\n      if (action.choiceId > -1) {\r\n        return state.map((obj) => {\r\n          const choice = obj;\r\n          if (choice.id === parseInt(action.choiceId, 10)) {\r\n            choice.selected = false;\r\n          }\r\n          return choice;\r\n        });\r\n      }\r\n\r\n      return state;\r\n    }\r\n\r\n    case 'FILTER_CHOICES': {\r\n      const filteredResults = action.results;\r\n      const filteredState = state.map((obj) => {\r\n        const choice = obj;\r\n        // Set active state based on whether choice is\r\n        // within filtered results\r\n        choice.active = filteredResults.some((result) => {\r\n          if (result.item.id === choice.id) {\r\n            choice.score = result.score;\r\n            return true;\r\n          }\r\n          return false;\r\n        });\r\n\r\n        return choice;\r\n      });\r\n\r\n      return filteredState;\r\n    }\r\n\r\n    case 'ACTIVATE_CHOICES': {\r\n      return state.map((obj) => {\r\n        const choice = obj;\r\n        choice.active = action.active;\r\n        return choice;\r\n      });\r\n    }\r\n\r\n    case 'CLEAR_CHOICES': {\r\n      return [];\r\n    }\r\n\r\n    default: {\r\n      return state;\r\n    }\r\n  }\r\n};\r\n\r\nexport default choices;\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/reducers/choices.js","export default class Dropdown {\r\n  constructor(instance, element, classNames) {\r\n    this.instance = instance;\r\n    this.element = element;\r\n    this.classNames = classNames;\r\n    this.dimensions = null;\r\n    this.position = null;\r\n    this.isActive = false;\r\n  }\r\n\r\n  /**\r\n   * Determine how far the top of our element is from\r\n   * the top of the window\r\n   * @return {Number} Vertical position\r\n   */\r\n  getVerticalPos() {\r\n    this.dimensions = this.element.getBoundingClientRect();\r\n    this.position = Math.ceil(this.dimensions.top + window.pageYOffset + this.element.offsetHeight);\r\n    return this.position;\r\n  }\r\n\r\n  /**\r\n   * Find element that matches passed selector\r\n   * @return {HTMLElement}\r\n   */\r\n  getChild(selector) {\r\n    return this.element.querySelector(selector);\r\n  }\r\n\r\n  /**\r\n   * Show dropdown to user by adding active state class\r\n   * @return {Object} Class instance\r\n   * @public\r\n   */\r\n  show() {\r\n    this.element.classList.add(this.classNames.activeState);\r\n    this.element.setAttribute('aria-expanded', 'true');\r\n    this.isActive = true;\r\n    return this.instance;\r\n  }\r\n\r\n  /**\r\n   * Hide dropdown from user\r\n   * @return {Object} Class instance\r\n   * @public\r\n   */\r\n  hide() {\r\n    this.element.classList.remove(this.classNames.activeState);\r\n    this.element.setAttribute('aria-expanded', 'false');\r\n    this.isActive = false;\r\n    return this.instance;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/components/dropdown.js","export default class Container {\r\n  constructor(instance, element) {\r\n    this.instance = instance;\r\n    this.element = element;\r\n    this.config = instance.config;\r\n    this.classNames = instance.config.classNames;\r\n    this.isOpen = false;\r\n    this.isFlipped = false;\r\n    this.isFocussed = false;\r\n    this.isDisabled = false;\r\n    this.isLoading = false;\r\n    this.onFocus = this.onFocus.bind(this);\r\n    this.onBlur = this.onBlur.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Add event listeners\r\n  */\r\n  addEventListeners() {\r\n    this.element.addEventListener('focus', this.onFocus);\r\n    this.element.addEventListener('blur', this.onBlur);\r\n  }\r\n\r\n  /**\r\n   * Remove event listeners\r\n  */\r\n\r\n  /** */\r\n  removeEventListeners() {\r\n    this.element.removeEventListener('focus', this.onFocus);\r\n    this.element.removeEventListener('blur', this.onBlur);\r\n  }\r\n\r\n  /**\r\n   * Set focussed state\r\n   */\r\n  onFocus() {\r\n    this.isFocussed = true;\r\n  }\r\n\r\n  /**\r\n   * Remove blurred state\r\n   */\r\n  onBlur() {\r\n    this.isFocussed = false;\r\n  }\r\n\r\n  /**\r\n   * Determine whether container should be flipped\r\n   * based on passed dropdown position\r\n   * @param {Number} dropdownPos\r\n   * @returns\r\n   */\r\n  shouldFlip(dropdownPos) {\r\n    if (!dropdownPos) {\r\n      return false;\r\n    }\r\n\r\n    const body = document.body;\r\n    const html = document.documentElement;\r\n    const winHeight = Math.max(\r\n      body.scrollHeight,\r\n      body.offsetHeight,\r\n      html.clientHeight,\r\n      html.scrollHeight,\r\n      html.offsetHeight,\r\n    );\r\n\r\n    // If flip is enabled and the dropdown bottom position is\r\n    // greater than the window height flip the dropdown.\r\n    let shouldFlip = false;\r\n    if (this.config.position === 'auto') {\r\n      shouldFlip = dropdownPos >= winHeight;\r\n    } else if (this.config.position === 'top') {\r\n      shouldFlip = true;\r\n    }\r\n\r\n    return shouldFlip;\r\n  }\r\n\r\n  /**\r\n   * Set active descendant attribute\r\n   * @param {Number} activeDescendant ID of active descendant\r\n   */\r\n  setActiveDescendant(activeDescendant) {\r\n    this.element.setAttribute('aria-activedescendant', activeDescendant);\r\n  }\r\n\r\n  /**\r\n   * Remove active descendant attribute\r\n   */\r\n  removeActiveDescendant() {\r\n    this.element.removeAttribute('aria-activedescendant');\r\n  }\r\n\r\n  open(dropdownPos) {\r\n    this.element.classList.add(this.classNames.openState);\r\n    this.element.setAttribute('aria-expanded', 'true');\r\n    this.isOpen = true;\r\n\r\n    if (this.shouldFlip(dropdownPos)) {\r\n      this.element.classList.add(this.classNames.flippedState);\r\n      this.isFlipped = true;\r\n    }\r\n  }\r\n\r\n  close() {\r\n    this.element.classList.remove(this.classNames.openState);\r\n    this.element.setAttribute('aria-expanded', 'false');\r\n    this.removeActiveDescendant();\r\n    this.isOpen = false;\r\n\r\n    // A dropdown flips if it does not have space within the page\r\n    if (this.isFlipped) {\r\n      this.element.classList.remove(this.classNames.flippedState);\r\n      this.isFlipped = false;\r\n    }\r\n  }\r\n\r\n  focus() {\r\n    if (!this.isFocussed) {\r\n      this.element.focus();\r\n    }\r\n  }\r\n\r\n  addFocusState() {\r\n    this.element.classList.add(this.classNames.focusState);\r\n  }\r\n\r\n  removeFocusState() {\r\n    this.element.classList.remove(this.classNames.focusState);\r\n  }\r\n\r\n  /**\r\n   * Remove disabled state\r\n   */\r\n  enable() {\r\n    this.element.classList.remove(this.config.classNames.disabledState);\r\n    this.element.removeAttribute('aria-disabled');\r\n    if (this.instance.isSelectOneElement) {\r\n      this.element.setAttribute('tabindex', '0');\r\n    }\r\n    this.isDisabled = false;\r\n  }\r\n\r\n  /**\r\n   * Set disabled state\r\n   */\r\n  disable() {\r\n    this.element.classList.add(this.config.classNames.disabledState);\r\n    this.element.setAttribute('aria-disabled', 'true');\r\n    if (this.instance.isSelectOneElement) {\r\n      this.element.setAttribute('tabindex', '-1');\r\n    }\r\n    this.isDisabled = true;\r\n  }\r\n\r\n  /**\r\n   * Add loading state to element\r\n   */\r\n  addLoadingState() {\r\n    this.element.classList.add(this.classNames.loadingState);\r\n    this.element.setAttribute('aria-busy', 'true');\r\n    this.isLoading = true;\r\n  }\r\n\r\n  /**\r\n   * Remove loading state from element\r\n   */\r\n  removeLoadingState() {\r\n    this.element.classList.remove(this.classNames.loadingState);\r\n    this.element.removeAttribute('aria-busy');\r\n    this.isLoading = false;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/components/container.js","import { getWidthOfInput } from '../lib/utils';\r\n\r\nexport default class Input {\r\n  constructor(instance, element) {\r\n    this.instance = instance;\r\n    this.element = element;\r\n    this.isFocussed = this.element === document.activeElement;\r\n    this.isDisabled = false;\r\n\r\n    // Bind event listeners\r\n    this.onPaste = this.onPaste.bind(this);\r\n    this.onInput = this.onInput.bind(this);\r\n    this.onFocus = this.onFocus.bind(this);\r\n    this.onBlur = this.onBlur.bind(this);\r\n  }\r\n\r\n  addEventListeners() {\r\n    this.element.addEventListener('input', this.onInput);\r\n    this.element.addEventListener('paste', this.onPaste);\r\n    this.element.addEventListener('focus', this.onFocus);\r\n    this.element.addEventListener('blur', this.onBlur);\r\n  }\r\n\r\n  removeEventListeners() {\r\n    this.element.removeEventListener('input', this.onInput);\r\n    this.element.removeEventListener('paste', this.onPaste);\r\n    this.element.removeEventListener('focus', this.onFocus);\r\n    this.element.removeEventListener('blur', this.onBlur);\r\n  }\r\n\r\n  /**\r\n   * Input event\r\n   * @return\r\n   * @private\r\n   */\r\n  onInput() {\r\n    if (!this.instance.isSelectOneElement) {\r\n      this.setWidth();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Paste event\r\n   * @param  {Object} e Event\r\n   * @return\r\n   * @private\r\n   */\r\n  onPaste(e) {\r\n    // Disable pasting into the input if option has been set\r\n    if (e.target === this.element && !this.instance.config.paste) {\r\n      e.preventDefault();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set focussed state\r\n   */\r\n  onFocus() {\r\n    this.isFocussed = true;\r\n  }\r\n\r\n  /**\r\n   * Remove focussed state\r\n   */\r\n  onBlur() {\r\n    this.isFocussed = false;\r\n  }\r\n\r\n  activate(focusInput) {\r\n    // Optionally focus the input if we have a search input\r\n    if (focusInput && this.instance.canSearch && document.activeElement !== this.element) {\r\n      this.element.focus();\r\n    }\r\n  }\r\n\r\n  deactivate(blurInput) {\r\n    this.removeActiveDescendant();\r\n    // Optionally blur the input if we have a search input\r\n    if (blurInput && this.instance.canSearch && document.activeElement === this.element) {\r\n      this.element.blur();\r\n    }\r\n  }\r\n\r\n  enable() {\r\n    this.element.removeAttribute('disabled');\r\n    this.isDisabled = false;\r\n  }\r\n\r\n  disable() {\r\n    this.element.setAttribute('disabled', '');\r\n    this.isDisabled = true;\r\n  }\r\n\r\n  focus() {\r\n    if (!this.isFocussed) {\r\n      this.element.focus();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value of input to blank\r\n   * @return {Object} Class instance\r\n   * @public\r\n   */\r\n  clear(setWidth = true) {\r\n    if (this.element.value) {\r\n      this.element.value = '';\r\n    }\r\n\r\n    if (setWidth) {\r\n      this.setWidth();\r\n    }\r\n\r\n    return this.instance;\r\n  }\r\n\r\n  /**\r\n   * Set the correct input width based on placeholder\r\n   * value or input value\r\n   * @return\r\n   */\r\n  setWidth(enforceWidth) {\r\n    if (this.instance.placeholder) {\r\n      // If there is a placeholder, we only want to set the width of the input when it is a greater\r\n      // length than 75% of the placeholder. This stops the input jumping around.\r\n      if (\r\n        (this.element.value &&\r\n        this.element.value.length >= (this.instance.placeholder.length / 1.25)) ||\r\n        enforceWidth\r\n      ) {\r\n        this.element.style.width = getWidthOfInput(this.element);\r\n      }\r\n    } else {\r\n      // If there is no placeholder, resize input to contents\r\n      this.element.style.width = getWidthOfInput(this.element);\r\n    }\r\n  }\r\n\r\n  setPlaceholder(placeholder) {\r\n    this.element.placeholder = placeholder;\r\n  }\r\n\r\n  setValue(value) {\r\n    this.element.value = value;\r\n  }\r\n\r\n  getValue() {\r\n    return this.element.value;\r\n  }\r\n\r\n  setActiveDescendant(activeDescendant) {\r\n    this.element.setAttribute('aria-activedescendant', activeDescendant);\r\n  }\r\n\r\n  removeActiveDescendant() {\r\n    this.element.removeAttribute('aria-activedescendant');\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/components/input.js","/* eslint-disable */\r\n\r\n/**\r\n * Capitalises the first letter of each word in a string\r\n * @param  {String} str String to capitalise\r\n * @return {String}     Capitalised string\r\n */\r\nexport const capitalise = function(str) {\r\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\r\n};\r\n\r\n/**\r\n * Generates a string of random chars\r\n * @param  {Number} length Length of the string to generate\r\n * @return {String} String of random chars\r\n */\r\nexport const generateChars = function(length) {\r\n  let chars = '';\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    const randomChar = getRandomNumber(0, 36);\r\n    chars += randomChar.toString(36);\r\n  }\r\n\r\n  return chars;\r\n};\r\n\r\n/**\r\n * Generates a unique id based on an element\r\n * @param  {HTMLElement} element Element to generate the id from\r\n * @param  {String} Prefix for the Id\r\n * @return {String} Unique Id\r\n */\r\nexport const generateId = function(element, prefix) {\r\n  let id = element.id || (element.name && (`${element.name}-${generateChars(2)}`)) || generateChars(4);\r\n  id = id.replace(/(:|\\.|\\[|\\]|,)/g, '');\r\n  id = prefix + id;\r\n\r\n  return id;\r\n};\r\n\r\n\r\n/**\r\n * Tests the type of an object\r\n * @param  {String}  type Type to test object against\r\n * @param  {Object}  obj  Object to be tested\r\n * @return {Boolean}\r\n */\r\nexport const getType = function(obj) {\r\n  return Object.prototype.toString.call(obj).slice(8, -1);\r\n};\r\n\r\n/**\r\n * Tests the type of an object\r\n * @param  {String}  type Type to test object against\r\n * @param  {Object}  obj  Object to be tested\r\n * @return {Boolean}\r\n */\r\nexport const isType = function(type, obj) {\r\n  const clas = getType(obj);\r\n  return obj !== undefined && obj !== null && clas === type;\r\n};\r\n\r\n/**\r\n * Tests to see if a passed object is a node\r\n * @param  {Object}  obj  Object to be tested\r\n * @return {Boolean}\r\n */\r\nexport const isNode = o => (\r\n    typeof Node === 'object' ? o instanceof Node :\r\n    o && typeof o === 'object' && typeof o.nodeType === 'number' && typeof o.nodeName === 'string'\r\n  );\r\n\r\n/**\r\n * Tests to see if a passed object is an element\r\n * @param  {Object}  obj  Object to be tested\r\n * @return {Boolean}\r\n */\r\nexport const isElement = o => (\r\n    typeof HTMLElement === 'object' ? o instanceof HTMLElement : // DOM2\r\n    o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\r\n  );\r\n\r\n/**\r\n * Merges unspecified amount of objects into new object\r\n * @private\r\n * @return {Object} Merged object of arguments\r\n */\r\nexport const extend = function() {\r\n  const extended = {};\r\n  const length = arguments.length;\r\n\r\n  /**\r\n   * Merge one object into another\r\n   * @param  {Object} obj  Object to merge into extended object\r\n   */\r\n  const merge = function(obj) {\r\n    for (const prop in obj) {\r\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n        // If deep merge and property is an object, merge properties\r\n         if (isType('Object', obj[prop])) {\r\n          extended[prop] = extend(true, extended[prop], obj[prop]);\r\n        } else {\r\n          extended[prop] = obj[prop];\r\n        }\r\n       }\r\n    }\r\n  };\r\n\r\n  // Loop through each passed argument\r\n  for (let i = 0; i < length; i++) {\r\n    // store argument at position i\r\n    const obj = arguments[i];\r\n\r\n    // If we are in fact dealing with an object, merge it.\r\n    if (isType('Object', obj)) {\r\n      merge(obj);\r\n    }\r\n  }\r\n\r\n  return extended;\r\n};\r\n\r\n/**\r\n * CSS transition end event listener\r\n * @return\r\n */\r\nexport const whichTransitionEvent = function() {\r\n  let t,\r\n    el = document.createElement('fakeelement');\r\n\r\n  const transitions = {\r\n    transition: 'transitionend',\r\n    OTransition: 'oTransitionEnd',\r\n    MozTransition: 'transitionend',\r\n    WebkitTransition: 'webkitTransitionEnd',\r\n  };\r\n\r\n  for (t in transitions) {\r\n    if (el.style[t] !== undefined) {\r\n      return transitions[t];\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * CSS animation end event listener\r\n * @return\r\n */\r\nexport const whichAnimationEvent = function() {\r\n  let t,\r\n    el = document.createElement('fakeelement');\r\n\r\n  const animations = {\r\n    animation: 'animationend',\r\n    OAnimation: 'oAnimationEnd',\r\n    MozAnimation: 'animationend',\r\n    WebkitAnimation: 'webkitAnimationEnd',\r\n  };\r\n\r\n  for (t in animations) {\r\n    if (el.style[t] !== undefined) {\r\n      return animations[t];\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n *  Get the ancestors of each element in the current set of matched elements,\r\n *  up to but not including the element matched by the selector\r\n * @param  {NodeElement} elem     Element to begin search from\r\n * @param  {NodeElement} parent   Parent to find\r\n * @param  {String} selector Class to find\r\n * @return {Array}          Array of parent elements\r\n */\r\nexport const getParentsUntil = function(elem, parent, selector) {\r\n  const parents = [];\r\n  // Get matches\r\n  for (; elem && elem !== document; elem = elem.parentNode) {\r\n    // Check if parent has been reached\r\n    if (parent) {\r\n      const parentType = parent.charAt(0);\r\n\r\n      // If parent is a class\r\n      if (parentType === '.') {\r\n        if (elem.classList.contains(parent.substr(1))) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // If parent is an ID\r\n      if (parentType === '#') {\r\n        if (elem.id === parent.substr(1)) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // If parent is a data attribute\r\n      if (parentType === '[') {\r\n        if (elem.hasAttribute(parent.substr(1, parent.length - 1))) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // If parent is a tag\r\n      if (elem.tagName.toLowerCase() === parent) {\r\n        break;\r\n      }\r\n    }\r\n    if (selector) {\r\n      const selectorType = selector.charAt(0);\r\n\r\n      // If selector is a class\r\n      if (selectorType === '.') {\r\n        if (elem.classList.contains(selector.substr(1))) {\r\n          parents.push(elem);\r\n        }\r\n      }\r\n\r\n      // If selector is an ID\r\n      if (selectorType === '#') {\r\n        if (elem.id === selector.substr(1)) {\r\n          parents.push(elem);\r\n        }\r\n      }\r\n\r\n      // If selector is a data attribute\r\n      if (selectorType === '[') {\r\n        if (elem.hasAttribute(selector.substr(1, selector.length - 1))) {\r\n          parents.push(elem);\r\n        }\r\n      }\r\n\r\n      // If selector is a tag\r\n      if (elem.tagName.toLowerCase() === selector) {\r\n        parents.push(elem);\r\n      }\r\n    } else {\r\n      parents.push(elem);\r\n    }\r\n  }\r\n\r\n  // Return parents if any exist\r\n  if (parents.length === 0) {\r\n    return null;\r\n  }\r\n  return parents;\r\n};\r\n\r\nexport const wrap = function(element, wrapper) {\r\n  wrapper = wrapper || document.createElement('div');\r\n  if (element.nextSibling) {\r\n    element.parentNode.insertBefore(wrapper, element.nextSibling);\r\n  } else {\r\n    element.parentNode.appendChild(wrapper);\r\n  }\r\n  return wrapper.appendChild(element);\r\n};\r\n\r\nexport const getSiblings = function(elem) {\r\n  const siblings = [];\r\n  let sibling = elem.parentNode.firstChild;\r\n  for (; sibling; sibling = sibling.nextSibling) {\r\n    if (sibling.nodeType === 1 && sibling !== elem) {\r\n      siblings.push(sibling);\r\n    }\r\n  }\r\n  return siblings;\r\n};\r\n\r\n/**\r\n * Find ancestor in DOM tree\r\n * @param  {NodeElement} el  Element to start search from\r\n * @param  {[type]} cls Class of parent\r\n * @return {NodeElement}     Found parent element\r\n */\r\nexport const findAncestor = function(el, cls) {\r\n  while ((el = el.parentElement) && !el.classList.contains(cls));\r\n  return el;\r\n};\r\n\r\n/**\r\n * Find ancestor in DOM tree by attribute name\r\n * @param  {NodeElement} el  Element to start search from\r\n * @param  {string} attr Attribute name of parent\r\n * @return {?NodeElement}     Found parent element or null\r\n */\r\nexport const findAncestorByAttrName = function(el, attr) {\r\n  let target = el;\r\n\r\n  while (target) {\r\n    if (target.hasAttribute(attr)) {\r\n      return target;\r\n    }\r\n\r\n    target = target.parentElement;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n/**\r\n * Debounce an event handler.\r\n * @param  {Function} func      Function to run after wait\r\n * @param  {Number} wait      The delay before the function is executed\r\n * @param  {Boolean} immediate  If  passed, trigger the function on the leading edge, instead of the trailing.\r\n * @return {Function}           A function will be called after it stops being called for a given delay\r\n */\r\nexport const debounce = function(func, wait, immediate) {\r\n  let timeout;\r\n  return function() {\r\n    let context = this,\r\n      args = arguments;\r\n    const later = function() {\r\n      timeout = null;\r\n      if (!immediate) func.apply(context, args);\r\n    };\r\n    const callNow = immediate && !timeout;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(later, wait);\r\n    if (callNow) func.apply(context, args);\r\n  };\r\n};\r\n\r\n/**\r\n * Get an element's distance from the top of the page\r\n * @private\r\n * @param  {NodeElement} el Element to test for\r\n * @return {Number} Elements Distance from top of page\r\n */\r\nexport const getElemDistance = function(el) {\r\n  let location = 0;\r\n  if (el.offsetParent) {\r\n    do {\r\n      location += el.offsetTop;\r\n      el = el.offsetParent;\r\n    } while (el);\r\n  }\r\n  return location >= 0 ? location : 0;\r\n};\r\n\r\n/**\r\n * Determine element height multiplied by any offsets\r\n * @private\r\n * @param  {HTMLElement} el Element to test for\r\n * @return {Number}    Height of element\r\n */\r\nexport const getElementOffset = function(el, offset) {\r\n  let elOffset = offset;\r\n  if (elOffset > 1) elOffset = 1;\r\n  if (elOffset > 0) elOffset = 0;\r\n\r\n  return Math.max(el.offsetHeight * elOffset);\r\n};\r\n\r\n/**\r\n * Get the next or previous element from a given start point\r\n * @param  {HTMLElement} startEl    Element to start position from\r\n * @param  {String}      className  The class we will look through\r\n * @param  {Number}      direction  Positive next element, negative previous element\r\n * @return {[HTMLElement}           Found element\r\n */\r\nexport const getAdjacentEl = (startEl, className, direction = 1) => {\r\n  if (!startEl || !className) return;\r\n\r\n  const parent = startEl.parentNode.parentNode;\r\n  const children = Array.from(parent.querySelectorAll(className));\r\n\r\n  const startPos = children.indexOf(startEl);\r\n  const operatorDirection = direction > 0 ? 1 : -1;\r\n\r\n  return children[startPos + operatorDirection];\r\n};\r\n\r\n/**\r\n * Get scroll position based on top/bottom position\r\n * @private\r\n * @return {String} Position of scroll\r\n */\r\nexport const getScrollPosition = function(position) {\r\n  if (position === 'bottom') {\r\n    // Scroll position from the bottom of the viewport\r\n    return Math.max((window.scrollY || window.pageYOffset) + (window.innerHeight || document.documentElement.clientHeight));\r\n  }\r\n    // Scroll position from the top of the viewport\r\n  return (window.scrollY || window.pageYOffset);\r\n};\r\n\r\n/**\r\n * Determine whether an element is within the viewport\r\n * @param  {HTMLElement}  el Element to test\r\n * @return {String} Position of scroll\r\n * @return {Boolean}\r\n */\r\nexport const isInView = function(el, position, offset) {\r\n  // If the user has scrolled further than the distance from the element to the top of its parent\r\n  return this.getScrollPosition(position) > (this.getElemDistance(el) + this.getElementOffset(el, offset));\r\n};\r\n\r\n/**\r\n * Determine whether an element is within\r\n * @param  {HTMLElement} el        Element to test\r\n * @param  {HTMLElement} parent    Scrolling parent\r\n * @param  {Number} direction      Whether element is visible from above or below\r\n * @return {Boolean}\r\n */\r\nexport const isScrolledIntoView = (el, parent, direction = 1) => {\r\n  if (!el) return;\r\n\r\n  let isVisible;\r\n\r\n  if (direction > 0) {\r\n    // In view from bottom\r\n    isVisible = (parent.scrollTop + parent.offsetHeight) >= (el.offsetTop + el.offsetHeight);\r\n  } else {\r\n    // In view from top\r\n    isVisible = el.offsetTop >= parent.scrollTop;\r\n  }\r\n\r\n  return isVisible;\r\n};\r\n\r\n/**\r\n * Remove html tags from a string\r\n * @param  {String}  Initial string/html\r\n * @return {String}  Sanitised string\r\n */\r\nexport const stripHTML = function(html) {\r\n  const el = document.createElement('DIV');\r\n  el.innerHTML = html;\r\n  return el.textContent || el.innerText || '';\r\n};\r\n\r\n/**\r\n * Adds animation to an element and removes it upon animation completion\r\n * @param  {Element} el        Element to add animation to\r\n * @param  {String} animation Animation class to add to element\r\n * @return\r\n */\r\nexport const addAnimation = (el, animation) => {\r\n  const animationEvent = whichAnimationEvent();\r\n\r\n  const removeAnimation = () => {\r\n    el.classList.remove(animation);\r\n    el.removeEventListener(animationEvent, removeAnimation, false);\r\n  };\r\n\r\n  el.classList.add(animation);\r\n  el.addEventListener(animationEvent, removeAnimation, false);\r\n};\r\n\r\n\r\n/**\r\n * Get a random number between a range\r\n * @param  {Number} min Minimum range\r\n * @param  {Number} max Maximum range\r\n * @return {Number}     Random number\r\n */\r\nexport const getRandomNumber = function(min, max) {\r\n  return Math.floor(Math.random() * (max - min) + min);\r\n};\r\n\r\n/**\r\n * Turn a string into a node\r\n * @param  {String} String to convert\r\n * @return {HTMLElement}   Converted node element\r\n */\r\nexport const strToEl = (function() {\r\n  const tmpEl = document.createElement('div');\r\n  return function(str) {\r\n    const cleanedInput = str.trim();\r\n    let r;\r\n    tmpEl.innerHTML = cleanedInput;\r\n    r = tmpEl.children[0];\r\n\r\n    while (tmpEl.firstChild) {\r\n      tmpEl.removeChild(tmpEl.firstChild);\r\n    }\r\n\r\n    return r;\r\n  };\r\n}());\r\n\r\n/**\r\n * Sets the width of a passed input based on its value\r\n * @return {Number} Width of input\r\n */\r\nexport const getWidthOfInput = (input) => {\r\n  const value = input.value || input.placeholder;\r\n  let width = input.offsetWidth;\r\n\r\n  if (value) {\r\n    const testEl = strToEl(`<span>${value}</span>`);\r\n    testEl.style.position = 'absolute';\r\n    testEl.style.padding = '0';\r\n    testEl.style.top = '-9999px';\r\n    testEl.style.left = '-9999px';\r\n    testEl.style.width = 'auto';\r\n    testEl.style.whiteSpace = 'pre';\r\n\r\n    if (document.body.contains(input) && window.getComputedStyle) {\r\n      const inputStyle = window.getComputedStyle(input);\r\n\r\n      if (inputStyle) {\r\n        testEl.style.fontSize = inputStyle.fontSize;\r\n        testEl.style.fontFamily = inputStyle.fontFamily;\r\n        testEl.style.fontWeight = inputStyle.fontWeight;\r\n        testEl.style.fontStyle = inputStyle.fontStyle;\r\n        testEl.style.letterSpacing = inputStyle.letterSpacing;\r\n        testEl.style.textTransform = inputStyle.textTransform;\r\n        testEl.style.padding = inputStyle.padding;\r\n      }\r\n    }\r\n\r\n    document.body.appendChild(testEl);\r\n\r\n    if (value && testEl.offsetWidth !== input.offsetWidth) {\r\n      width = testEl.offsetWidth + 4;\r\n    }\r\n\r\n    document.body.removeChild(testEl);\r\n  }\r\n\r\n  return `${width}px`;\r\n};\r\n\r\n/**\r\n * Sorting function for current and previous string\r\n * @param  {String} a Current value\r\n * @param  {String} b Next value\r\n * @return {Number}   -1 for after previous,\r\n *                    1 for before,\r\n *                    0 for same location\r\n */\r\nexport const sortByAlpha = (a, b) => {\r\n  const labelA = (a.label || a.value).toLowerCase();\r\n  const labelB = (b.label || b.value).toLowerCase();\r\n\r\n  if (labelA < labelB) return -1;\r\n  if (labelA > labelB) return 1;\r\n  return 0;\r\n};\r\n\r\n/**\r\n * Sort by numeric score\r\n * @param  {Object} a Current value\r\n * @param  {Object} b Next value\r\n * @return {Number}   -1 for after previous,\r\n *                    1 for before,\r\n *                    0 for same location\r\n */\r\nexport const sortByScore = (a, b) => a.score - b.score;\r\n\r\n/**\r\n * Trigger native event\r\n * @param  {NodeElement} element Element to trigger event on\r\n * @param  {String} type         Type of event to trigger\r\n * @param  {Object} customArgs   Data to pass with event\r\n * @return {Object}              Triggered event\r\n */\r\nexport const triggerEvent = (element, type, customArgs = null) => {\r\n  const event = new CustomEvent(type, {\r\n    detail: customArgs,\r\n    bubbles: true,\r\n    cancelable: true,\r\n  });\r\n\r\n  return element.dispatchEvent(event);\r\n};\r\n\r\n/**\r\n * Tests value against a regular expression\r\n * @param  {string} value   Value to test\r\n * @return {Boolean}        Whether test passed/failed\r\n * @private\r\n */\r\nexport const regexFilter = (value, regex) => {\r\n  if (!value || !regex) {\r\n    return false;\r\n  }\r\n\r\n  const expression = new RegExp(regex.source, 'i');\r\n  return expression.test(value);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/lib/utils.js","export default class List {\r\n  constructor(instance, element) {\r\n    this.instance = instance;\r\n    this.element = element;\r\n    this.classNames = this.instance.config.classNames;\r\n    this.scrollPos = this.element.scrollTop;\r\n    this.height = this.element.offsetHeight;\r\n    this.hasChildren = !!this.element.children;\r\n  }\r\n\r\n  /**\r\n   * Clear List contents\r\n   */\r\n  clear() {\r\n    this.element.innerHTML = '';\r\n  }\r\n\r\n  /**\r\n   * Scroll to passed position on Y axis\r\n   */\r\n  scrollTo(scrollPos) {\r\n    this.element.scrollTop = scrollPos;\r\n  }\r\n\r\n  /**\r\n   * Append node to element\r\n   */\r\n  append(node) {\r\n    this.element.appendChild(node);\r\n  }\r\n\r\n  /**\r\n   * Find element that matches passed selector\r\n   * @return {HTMLElement}\r\n  */\r\n  getChild(selector) {\r\n    return this.element.querySelector(selector);\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/components/list.js","export const addItem = (\r\n  value,\r\n  label,\r\n  id,\r\n  choiceId,\r\n  groupId,\r\n  customProperties,\r\n  placeholder,\r\n  keyCode,\r\n) => ({\r\n  type: 'ADD_ITEM',\r\n  value,\r\n  label,\r\n  id,\r\n  choiceId,\r\n  groupId,\r\n  customProperties,\r\n  placeholder,\r\n  keyCode,\r\n});\r\n\r\nexport const removeItem = (id, choiceId) => ({\r\n  type: 'REMOVE_ITEM',\r\n  id,\r\n  choiceId,\r\n});\r\n\r\nexport const highlightItem = (id, highlighted) => ({\r\n  type: 'HIGHLIGHT_ITEM',\r\n  id,\r\n  highlighted,\r\n});\r\n\r\nexport const addChoice = (\r\n  value,\r\n  label,\r\n  id,\r\n  groupId,\r\n  disabled,\r\n  elementId,\r\n  customProperties,\r\n  placeholder,\r\n  keyCode,\r\n) => ({\r\n  type: 'ADD_CHOICE',\r\n  value,\r\n  label,\r\n  id,\r\n  groupId,\r\n  disabled,\r\n  elementId,\r\n  customProperties,\r\n  placeholder,\r\n  keyCode,\r\n});\r\n\r\nexport const filterChoices = results => ({\r\n  type: 'FILTER_CHOICES',\r\n  results,\r\n});\r\n\r\nexport const activateChoices = (active = true) => ({\r\n  type: 'ACTIVATE_CHOICES',\r\n  active,\r\n});\r\n\r\nexport const clearChoices = () => ({\r\n  type: 'CLEAR_CHOICES',\r\n});\r\n\r\nexport const addGroup = (value, id, active, disabled) => ({\r\n  type: 'ADD_GROUP',\r\n  value,\r\n  id,\r\n  active,\r\n  disabled,\r\n});\r\n\r\nexport const clearAll = () => ({\r\n  type: 'CLEAR_ALL',\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/actions/actions.js","/* eslint-disable */\r\n(function () {\r\n  // Production steps of ECMA-262, Edition 6, 22.1.2.1\r\n  // Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from\r\n  if (!Array.from) {\r\n    Array.from = (function() {\r\n      let toStr = Object.prototype.toString;\r\n\r\n      let isCallable = function(fn) {\r\n        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\r\n      };\r\n\r\n      let toInteger = function(value) {\r\n        let number = Number(value);\r\n        if (isNaN(number)) {\r\n          return 0;\r\n        }\r\n        if (number === 0 || !isFinite(number)) {\r\n          return number;\r\n        }\r\n        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\r\n      };\r\n\r\n      let maxSafeInteger = Math.pow(2, 53) - 1;\r\n\r\n      let toLength = function(value) {\r\n        let len = toInteger(value);\r\n        return Math.min(Math.max(len, 0), maxSafeInteger);\r\n      };\r\n\r\n      // The length property of the from method is 1.\r\n      return function from(arrayLike /* , mapFn, thisArg */) {\r\n        // 1. Let C be the this value.\r\n        let C = this;\r\n\r\n        // 2. Let items be ToObject(arrayLike).\r\n        let items = Object(arrayLike);\r\n\r\n        // 3. ReturnIfAbrupt(items).\r\n        if (arrayLike == null) {\r\n          throw new TypeError('Array.from requires an array-like object - not null or undefined');\r\n        }\r\n\r\n        // 4. If mapfn is undefined, then let mapping be false.\r\n        let mapFn = arguments.length > 1 ? arguments[1] : void undefined;\r\n        let T;\r\n        if (typeof mapFn !== 'undefined') {\r\n          // 5. else\r\n          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\r\n          if (!isCallable(mapFn)) {\r\n            throw new TypeError('Array.from: when provided, the second argument must be a function');\r\n          }\r\n\r\n          // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\r\n          if (arguments.length > 2) {\r\n            T = arguments[2];\r\n          }\r\n        }\r\n\r\n        // 10. Let lenValue be Get(items, \"length\").\r\n        // 11. Let len be ToLength(lenValue).\r\n        let len = toLength(items.length);\r\n\r\n        // 13. If IsConstructor(C) is true, then\r\n        // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.\r\n        // 14. a. Else, Let A be ArrayCreate(len).\r\n        let A = isCallable(C) ? Object(new C(len)) : new Array(len);\r\n\r\n        // 16. Let k be 0.\r\n        let k = 0;\r\n        // 17. Repeat, while k < len… (also steps a - h)\r\n        let kValue;\r\n        while (k < len) {\r\n          kValue = items[k];\r\n          if (mapFn) {\r\n            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\r\n          } else {\r\n            A[k] = kValue;\r\n          }\r\n          k += 1;\r\n        }\r\n        // 18. Let putStatus be Put(A, \"length\", len, true).\r\n        A.length = len;\r\n        // 20. Return A.\r\n        return A;\r\n      };\r\n    }());\r\n  }\r\n\r\n  // Reference: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find\r\n  if (!Array.prototype.find) {\r\n    Array.prototype.find = function(predicate) {\r\n      'use strict';\r\n\r\n      if (this == null) {\r\n        throw new TypeError('Array.prototype.find called on null or undefined');\r\n      }\r\n      if (typeof predicate !== 'function') {\r\n        throw new TypeError('predicate must be a function');\r\n      }\r\n      let list = Object(this);\r\n      let length = list.length >>> 0;\r\n      let thisArg = arguments[1];\r\n      let value;\r\n\r\n      for (let i = 0; i < length; i++) {\r\n        value = list[i];\r\n        if (predicate.call(thisArg, value, i, list)) {\r\n          return value;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n  }\r\n\r\n  function CustomEvent (event, params) {\r\n    params = params || {\r\n      bubbles: false,\r\n      cancelable: false,\r\n      detail: undefined,\r\n    };\r\n    let evt = document.createEvent('CustomEvent');\r\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n    return evt;\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype;\r\n\r\n  window.CustomEvent = CustomEvent;\r\n}());\r\n\n\n\n// WEBPACK FOOTER //\n// src/scripts/src/lib/polyfills.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAUA;AACA;AAeA;AACA;;;;;;;;;AACA;;;AAGA;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BA;AA4BA;AACA;AADA;AAGA;AACA;AArEA;AACA;AAuEA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAtBA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AAAA;AACA;AA8BA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAQA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAxCA;AACA;AA0CA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AADA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AADA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AACA;AAsBA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AACA;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAWA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAYA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AASA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AASA;AACA;AACA;AAQA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAMA;AAGA;AACA;AAAA;AAAA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAOA;AAAA;AACA;AAAA;AACA;AAOA;AAqBA;AACA;AACA;AAYA;AACA;AACA;AACA;AAGA;AASA;AACA;AACA;AACA;AACA;AAKA;AAYA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAQA;AAiBA;AACA;AACA;AACA;AAIA;AAWA;AACA;AACA;AACA;AAIA;AAOA;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAOA;AAKA;AACA;AAAA;AAAA;AAtNA;AACA;AA0NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;AACA;;;;;;;AC7pFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/CA;AACA;AAAA;AACA;;;;;;;;;AACA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;;;;;;AA7KA;AACA;AACA;AA8KA;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5BA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;AACA;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhDA;AAkDA;AACA;;;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAhBA;AAkBA;AACA;;;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAnGA;AAqGA;AACA;;;;;;;;;;;;;;;;;ACvGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAnDA;;;;;;;;;;;;;;;;ACAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AA7KA;;;;;;;;;;;;;;ACAA;AACA;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AA1JA;;;;;;;;;;;;;;ACFA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AAAA;AACA;AAIA;;;;;AAKA;AAAA;AAEA;AAFA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AAAA;AAAA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtkBA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;;;AArCA;;;;;;;;;;;ACAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AATA;AACA;AAoBA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AACA;AAKA;AAAA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAVA;AACA;AAsBA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AAIA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AAIA;AAAA;AACA;AADA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AACA;AAOA;AAAA;AACA;AADA;AAAA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;","sourceRoot":""}